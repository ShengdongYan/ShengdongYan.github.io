{"pages":[{"title":"关于","date":"2019-04-07T18:35:53.547Z","updated":"2019-04-07T18:35:53.547Z","comments":false,"path":"about/index.html","permalink":"http://dongdongyan.com/about/index.html","excerpt":"","text":"关于我："},{"title":"分类","date":"2019-04-07T17:46:04.823Z","updated":"2019-04-07T17:46:04.823Z","comments":false,"path":"categories/index.html","permalink":"http://dongdongyan.com/categories/index.html","excerpt":"","text":""},{"title":"项目仓库","date":"2019-04-07T17:40:25.454Z","updated":"2019-04-07T17:40:25.454Z","comments":false,"path":"repository/index.html","permalink":"http://dongdongyan.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-07T17:46:50.558Z","updated":"2019-04-07T17:46:50.558Z","comments":true,"path":"links/index.html","permalink":"http://dongdongyan.com/links/index.html","excerpt":"","text":""},{"title":"我的相册","date":"2019-04-07T18:12:21.470Z","updated":"2019-04-07T18:12:21.470Z","comments":true,"path":"photo/index.html","permalink":"http://dongdongyan.com/photo/index.html","excerpt":"","text":"待开发。。。。。。"},{"title":"标签","date":"2019-04-07T17:45:34.065Z","updated":"2019-04-07T17:45:34.065Z","comments":false,"path":"tags/index.html","permalink":"http://dongdongyan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础知识（持续更新）","slug":"Java基础知识（持续更新）","date":"2019-07-01T15:20:31.000Z","updated":"2019-07-03T14:21:47.276Z","comments":true,"path":"2019/07/01/Java基础知识（持续更新）/","link":"","permalink":"http://dongdongyan.com/2019/07/01/Java基础知识（持续更新）/","excerpt":"","text":"最近在读Java圣经-Java编程思想/Thingking in Java 第四版， 正好以笔记的形式整理一份Java的基础知识。Java-OOP编程的基础思想万物皆对象，我们应该想办法构造对象，然后对于这些对象以单位进行操作。（当然，对象都来自于不同的类，或者说类型）。每个对象应该尽可能的简单，只针对特定的功能，或者只针对特定的一个问题而创造，而不是想把所有问题都用一个类来解决。（对于更多的设计模式或者编程思路，我后期会再单独开一篇,这里就不多阐述了）关键字 访问权限（access specifier） public,private,protected,defaultpublic：具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于 对外 的情况，也就是对象或类对外的一种接口的形式。protected：主要的作用就是用来保护 子类 的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西default：有时候也称为friendly，它是针对 本包访问 而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。private：访问权限仅限于类的 内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。所有private的东西不会被继承。关键字 方法的继承模式- overload, override, overwrite.区分方法是否相同(/是否重载)与访问权限和返回类型无关, 只看名字+输入参数（包括参数数量，顺序，类型 ：1234567public void add()&#123;&#125; private void add()&#123;&#125; //是同一个方法,不允许同时出现。---------------------------------------------public int add(int a , int b)&#123;&#125;public double add(int a, int b)&#123;&#125; // 不允许，名同和参数同。overlaod（重载）: 是一个全新的方法，只是于原方法的名字相同，输入参数的类型或者数量或者参数的顺序或返回类型都可能不同。于多态无关override覆盖（重写，复写）: 覆盖父类或者接口中的方法，方法名同，参数同，返回类型同，只有内容不同。 贡献了多态性 注意，构造器和私有变量都不能被继承，所以对于构造器都是overloadoverwrite: java里没有，相当于override.补充：封装、抽象、继承和多态。封装：在面向对象语言中，封装特性是由类来体现的，我们将现实生活中的一类实体定义成类，其中包括属性和行为（在Java中就是方法），就好像人类，可以具有name,sex,age等属性，同时也具有eat(),sleep()等行为，我们在行为中实现一定的功能，也可操作属性，这是面向对象的封装特性；抽象：抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。比如鸟就是一个抽象实体，因为抽象实体并不是一个真正的对象，它的属性还不能完全描述一个对象，所以在语言中体现为抽象类不能实例化；继承：继承就像是我们现实生活中的父子关系，儿子可以遗传父亲的一些特性，在面向对象语言中，就是一个类可以继承另一个类的一些特性，从而可以代码重用，其实继承体现的是is-a关系，父类同子类在本质上还是一类实体；多态：多态就是通过传递给父类对象引用不同的子类对象从而表现出不同的行为 、、所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。可以通过 继承和接口体现 …类和类的关系- is-a, is-like-a,has-a;is-a: 继承关系，子类的全部接口（方法）在父类里也有is-like-a: 继承关系，子类里新增了一些接口has-a: 一个类的对象成了另一个类的属性向上转型（upcast）和向下转型转型(downcast)：详细内容参考：Java向上转型和向下转型把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。如Father father = new Son();把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型,要向下转型，必须先向上转型为了安全可以用instanceof判断。如father就是一个指向子类对象的父类引用，把father赋给子类引用son 即Son son =（Son）father；其中father前面的（Son）必须添加，进行强制转换。upcasting 会丢失子类特有的方法(只能调用父类中存在的方法和属性),但是子类overriding 父类的方法，子类方法有效（同名不同内容的变量也一样道理），向上转型只能引用父类对象的属性，要引用子类对象的同名属性，则要写getter函数 ,不可以.属性如：1234567891011// 父类有一个方法 public void add(Father f)&#123; System.out.println(f.name);&#125; //这样只会返回Father类里的name,就算后来输入的是son. 所以应该如下：public String getName()&#123; return this.name;&#125;public void add(Father f)&#123; System.out.println(f.getName());&#125;向上转型的作用，当用大家都有的方法时，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。（坏处就是如果向上转型后，如果还想调用子类独有的方法，还要向下强制转型，所以其实向下转型是一种向上转型的附属品）如：12345678public void add(Father f)&#123;&#125;//在调用时可以add(new Son());//或者Son s = new Son(); add(s); //节省了代码量,因为当有很多子类时，不用对所有的子类类型都写一个add（Son1 s），add(Son2 s)方法单根集成结构：所有OOP语言（除了C++外），所有的类都最终集成自单一的基类，（Java是都来自Object类）； 好处： 1.垃圾回收很容易（相比于C++的重要改进） 2. 方便确定变量类型，进而处理异常。7. Java 数据类型：Java中的变量分为基本类型和引用类型两种。基本类型的变量保存数值本身，而引用类型的变量保存的是引用值，即指向内存空间的地址。 八大基本类型包括：byte,char,int short,long,float,double,boolean; (大写的 String, Integer, Double等是其对应的包装类) 引用类型包括：类类型，接口类型和数组。 在声明基本数据类型时，计算机就分配了内存空间： *基本类型在声明其变量时就为它分配了空间，而且 变量名字直接代表内存地址*： 1231 int value; 2 3 value = 10;//正确，因为声明a时就分配了空间*而引用不同，在进行引用的声明时只给变量声明了引用空间，而不分配数据空间，类名只是一种引用，引用了真正存内容的首位地址（由此牵扯出判断两个对象的内容是否相等的方法在第17中会提及）：123456789101112 Date date; //执行实例化，开辟数据空间存放Date对象，然后把空间的首地址传给today变量 date=new Date(); //如果注释掉上一步操作 //The local variable date may not have been initialized //也就是说对象的数据空间没有分配 date.getDate();//初始化过程如下：Date a,b; //在内存开辟两个引用空间, 现在不能a = new Date();//开辟存储Date对象的数据空间，并把该空间的首地址赋给a b = a; //将a存储空间中的地址写到b的存储空间中所以写代码的时候有一种简化代码的思路是，省去引用，直接利用对应的对象或者结果，而不是先new 再利用,尤其是当这个引用只下下面紧接着的一部分被利用如：123456 this.add（new Integer(22); // 等于this.add(22); 而不是 int a = 22; this.add(a);boolean test(int i1, int i2 )&#123; return i1==i2;&#125;补充： 形参： 传入方法或者类的参数 如: void add(int a){}// int a 是形参 实参：实际操作针对的参数，如 int a = 10; add(a); // a 为实参 1）形参为基本类型时，对形参的处理不会影响实参。 void add(int a){ a++;// 不会影响外部的a 值。 } 2）*形参为引用类型时，对形参的处理会影响实参。* Date a = new Date(); void add(Date a){ a.setTime(123);// 会影响外部的a。 } 3）String,Integer,Double等immutable类型的特殊处理，可以理解为值传递，形参操作不会影响实参对象。 看一个有趣的例子： 另外，假如Tank里有一个变量 int a =10; 如果改变了Tank.a他所有的子类里的a的值都会变化。 泛型 GenericType（参数化类型）出现自JavaSE5 以后：详细内容：Java泛型典型例子ArryListlist = new ArrayList();String 就是参数化类型的应用所在。 在Java5之前，我们在这种集合类中都是默认存入的是Object类,存入时我们要向上转型到Object类，取出时我们还需要人为记住每一个位置的类型并强制向下转型，很麻烦（其实现在内部也是存入的Object，只是我们看不到）。好处：1 可读性，从字面上就可以判断集合中的内容类型；2 类型检查，避免插入非法类型。3 获取数据时不在需要强制类型转换。(补充： 遇到’E’,’T’,’A’,,&lt;K,V&gt;等，是用到了java中的泛型。 一般使用来声明类型持有者名称，自定义泛型类时，类持有者名称可以使用T(Type) 如果是容器的元素可以使用E(Element)，若键值匹配可以用K(Key)和V(Value)等， 若是&lt;?&gt;，则是默认是允许Object及其下的子类，也就是java的所有对象了。所以说，如果是字母A,B,C,D…定义的，就是泛型，这里T只是名字上的意义而已,你也可以用A，B等等： T—type,E—-Element K—-key, V—-value 如果是？定义的，就是普通的Object或者其子类 举例说明： Set表示 集合里 是 T类的实例 List表示 集合里是E类的实例 List&lt;?&gt; 表示 集合里的对象类型不确定，未指定List同 List&lt;?&gt; 是一样的。)通配符 wildcard:类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box、Box…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。123456789101112131415161718 1 public class GenericTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Box&lt;String&gt; name = new Box&lt;String&gt;(&quot;corn&quot;); 6 Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); 7 Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); 8 9 getData(name);10 getData(age);11 getData(number);12 &#125;13 14 public static void getData(Box&lt;?&gt; data) &#123;15 System.out.println(&quot;data :&quot; + data.getData());16 &#125;17 18 &#125;有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。1234567891011121314151617181920212223242526 1 public class GenericTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Box&lt;String&gt; name = new Box&lt;String&gt;(&quot;corn&quot;); 6 Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); 7 Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); 8 9 getData(name);10 getData(age);11 getData(number);12 13 //getUpperNumberData(name); // 114 getUpperNumberData(age); // 215 getUpperNumberData(number); // 316 &#125;17 18 public static void getData(Box&lt;?&gt; data) &#123;19 System.out.println(&quot;data :&quot; + data.getData());20 &#125;21 22 public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123;23 System.out.println(&quot;data :&quot; + data.getData());24 &#125;25 26 &#125; 此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。 类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。 总结:限定通配符总是包括自己上界类型通配符：add方法受限(因为无法确定具体存入类型)下界类型通配符：get方法受限（不强转）如果你想从一个数据类型里获取数据，使用 ? extends 通配符如果你想把对象写入一个数据结构里，使用 ? super 通配符如果你既想存，又想取，那就别用通配符不能同时声明泛型通配符上界和下界详细解释：储存区（包括堆栈）+基本类型详细介绍：来自于 Java编程思想第四版22页，我的github库里有一个专门的电子书籍整理，可自行下载。补充； Sting 类型的大小是每位字符都用2字节（16bits）来表示；BigInteger可以支持任何大小的整数，BigDecimal可以支持任何精度的小数。当基础数据类型作为类的数据成员时（global variable时），会有一个默认值,如下:1、整数类型（byte、short、int）的基本类型变量的默认值为0。2、单精度浮点型（float）的基本类型变量的默认值为0.0f。3、双精度浮点型（double）的基本类型变量的默认值为0.0d。4、字符型（char）的基本类型变量的默认为 “/u0000”。（null）5、布尔性的基本类型变量的默认值为 false。6、引用类型的变量是默认值为 null。7、long - 0l;8、数组引用类型的变量的默认值为 null。除关键数组变量的实例后，如果没有没有显示的为每个元素赋值，Java 就会把该数组的所有元素初始化为其相应类型的默认值。在作为local variable时必须手动初始化赋值9 基本数据类型间的转换关系: 向上转换可以直接隐式，向下转换必须强转（int）数据可能会丢失，包括大小范围，和精度12. 关键字 static:&gt;[Java static](https://www.cnblogs.com/dolphin0520/p/3799052.html) 1. static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化，所有新的对象会共享，（一个地方改变，其他地方也会变）。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进行初始化。static 不可以用来修饰局部变量（规定）。 2. “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 3. 所以在使用时，如果对于整个类都比较通用的变量或者方法，即静态的东西，就可以加上static. java.lang类包是默认导入每个文件里的，所以我们用的基础类型都不用额外import了。14. 代码执行顺序、初始化顺序：1.找main()方法， 加载 main所在类的static变量以及方法 2. 加载并初始化该类的其他变量，再执行main方法， 3. 如果main里new了一个类，先加载该类的父类（的static 变量和方法），然后加载自己的static变量和方法，接着为了执行他的构造器，发现有个父类4.初始化父类里的普通变量（没有指定地址的为null或者0），运行加载父类的构造器,给对应的变量赋值，5.最后才初始化自己的变量， 最后执行new 新建对象,给自己对应的变量赋值。简单来说就是当发现一个新的类时会直接先加载这个类的static的东西，当有方法要执行之前会加载该方法所在类的其他普通量。 （static 修饰的东西只会初始化一次，就是该类首次生成一个对象时）配合例子：static 面试题在类的构造器中尽可能只做赋值，而不调用方法，尤其是作为父类时， 否则子类运行构造函数之前就会再父类中运行在子类中重写的函数，但是子类中的有些变量可能还没有初始化，所以运行结果会是错误的。15. 编码风格（命名风格）- 驼峰风格：详见 ：Java命名规范+注释规范包名，项目名: 全小写；类名：每一个单词的首字母都大写其他部分小写：class AllTheColorsOfTheRaindow{//…}常量（static final的不怎么变化的量）： 全大写多个单词用_隔开；其他变量，包括方法名： 第一个单词首字母小写，其他的也是首字母大写void allTheColorsOfTheRaindow(){//….}16. 算数操作符：12345678910111213141516171819% 取模（结果代表余数） 3%6 =3;%= 取整数部分 3%=6 =0; int a = 5;a = a++;System.out.println(a); //5//或者 int a = 5; int b = 3 + a++; // b = 8 , a = 6;-------int a = 5;a = ++a;System.out.println(a);//6//或者 ，int a =5; int b = 3+ ++a; b = 9, a =6;17. 关系操作符： == 比较的是地址，不是内容（对于基本操作类型可以直接==比较）因为就像前面说的，Integer i = new Integer(3); // 这里的 i 只是引用了具体对象的首位地址， 所以 i1 == i2； 是相当于比较了两个对象的首位地址。比较内容用 equal方法，如果没有可以自己在类中override 写一个出来,如果没有重写，equal 方法默认比较的是地址，还是会返回false。注意： Integer i1 = new Integer(3);\\ Integer i2 = i1; System.out.println(i2==i1); //true 两个东西是相同的引用，指向同一个地址 重写equal方法的例子：123456789101112131415161718@overridepublic boolean equals(Object obj) &#123; //由于是重写，参数只能是Object oif (this == obj)return true;if (obj == null)return false;if (getClass() != obj.getClass())return false;Person other = (Person) obj;if (age != other.age)return false;if (name == null) &#123;if (other.name != null)return false;&#125; else if (!name.equals(other.name))return false;return true;&#125;补充：用equal和hashcode方法判断两个对象的内容是否相等总结： ==是判断引用地址； 重写 .equal（）方法是判断相对相等；hashcode一般是在重写.equal（）方法的同时也重写 一个 public int hashCode(){},如果不重写，每个对象的hashcode生成和该对象的存储地址，以及字段都有关系，一般用于往hashmap,hashset,hashtable添加对象的时候使用，如果hashcode相同了，再看equal是否为true,如果为true就代表两个元素相同，更新value值。这个方法是用来提高往哈希集中添加元素的效率，不用每次都调用equal去比较。因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是 不可以的，因为不同的对象可能会生成相同的hashcode值（比如a= 3+3, b =2+2+2）。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode 值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；如果两个对象的hashcode值相等，则equals方法得到的结果未知。18. 短路：boolean result = a&amp;&amp;b&amp;&amp;c; System.our.println(result);// a,b ,c 是三个 boolean值或者可以改成三个返回boolean的方法，只有a是true才会接着看b, 然后只有b是true,才会接着看c。 19. 三元操作符：简单的if-else逻辑时很好用,简洁：static int test(int a){ return a&gt;10 ? a/10 ： a*10; } 20. 字符串操作 +1234int x = 0 , y = 1, z= 2;String s = &quot;x,y,z&quot;; System.out.println(s+x+y+z); //结果是想x,y,z012, 以字符串开头的表达式，后续会自动转换成字符串，也必须是字符串。所以 “”+x 相当于 Integer.toString(x);System.out.println(s+(x+y+z));// 结果是x,y,z321.类型转换:小类型可以自动转化成大类型，但是大类型只能强制转化成小类型（因为信息会丢失）， 如 flaot f 和double d 转化成一个 int i =(int) f;这里都不会四舍五入，只会只保留整数部分， 同样的char, byte, short 在有需要的情况下会自动转化成 int. 一般一个运算最后的结果类型是以最大的类型为结果。1/0.5 = 2.0; 1/2 =0; char = 74+1 = j+1 =i; int i = ‘j’+3 = 77;八种基本类型站bit位如下：boolean: 1;byte: 8;char: 16;short: 16;int: 32;flaot: 32;double:64;long:64;22.常见的占位符：Java占位符大全1234567891011121314int year=2017;int month=6;int day=1;&lt;/P&gt;String str=String.format(&quot;今天是%d年%d月%d日，祝大家儿童节快乐！！！&quot;, year, month, day);//这样以来就不用一直用+号连接各部分了//如果toString() 里需要加的东西比较多，可以先这样建一个Srtring,再return,注意 不能直接return 带逗号的形式，识别不了//如果直接用于打印：注意println 是不行的！！System.out.printf(&quot;今天是%d年%d月%d日，祝大家儿童节快乐！！！&quot;, year, month, day); System.out.printf(&quot;A:%-8sp\\n&quot;,&quot;a&quot;); System.out.printf(&quot;B:%-8sp&quot;,&quot;b&quot;); //打印固定长度的字符串23.Java string和各种格式互转:简单收集记录下:其他类型转String与基本类型和包装类String s = String.valueOf( value); // 其中 value 为任意一种数字类型。字符串型转换成各种数字类型：String s = “169”;byte b = Byte.parseByte( s );short t = Short.parseShort( s );int i = Integer.parseInt( s );long l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );(或者都可以调用toString 方法)。与字节数组 byte[]字节数组—&gt;String : 直接String 的构造器String—&gt;字节数组： String.Bytes();与字符数组 char[]字符数组—&gt;String : 直接String的构造器String—&gt;字符数组： String.tocharArray();StringBuilder:StringBuilder s = new StringBuilder(String s);String S = s.toString();24. 递归的核心思想，从最简单最基础的情形做起，再让复杂的情形逐步的退回到最简单的情形再进行操作，详细例子看练习题。25. return, break,continue:return; : 直接结束一个方法。 void 方法里用 return; 就是这个用途； break; : 结束或者说跳出循环 continue;: 不再继续执行当前的循环，直接进入下一圈循环。 26. 可变参数列表：等于对应的array，只不过稍微更灵活一点： void test(Integer...args){ for(Integer i:args){ System.out.println(i); } } 在调用时： this.test(1,2,3,new Integer(4)); 、、这种就更灵活一点 27. 枚举类 enum: 在创建时，自动为他添加 to.String(); ordinal() ; .values()方法。 枚举类和switch语句配合非常好用。28. 一个 .java 文件（是一个编译单元）最多只有一个public类 ， 其他的类可以用 内部类的形式声明：public class A(){///} class b(){} class c(){}// 当你至于要一两个简单的类来支持类a的使用时，这样非常高效。 如果不想外部访问一个类，可以不写public， 但不能写成 private或者protected； 另一个方法是把类的构造器写成private。 29. 复用类的三种方式：1.组合（一个类的对象在另一个类中当成变量使用）2.继承3.代理： 一个类的对象a 在另一个B中作为变量声明（一般写成private），然后用类B的方法接口来传递输入到a,这样就既可以让用户有选择的使用a,又可以不用像继承一样把a的所有内容都暴露出来。30. 关键字 final(不变的,不能让该引用指向新的地址，或者说不能改变他的值，但是final 对象可以改变对象中的值，虽然不可以让该引用指向其他地址) (static可以理解为，静态的，事先加载的,不面向对象的，针对类):既是final 又是static 时，就只占据固定的内存，减少了计算负担，声明常量时非常好用。 全大写，字母与字母下划线隔开。 final修饰的方法，目的在于不让子类重写该方法。private 方法被归于final,也不能重写。 final类表示该类不可以被继承。 31. Java 中除了final 和static方法外，所有方法都是动态绑定，也就是说只有在运行的的时候才知道具体调用这个方法的对象。 Java中所有的方法都是通过这种动态绑定实现了多态。32. 关键字 abstract:抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象类。抽象方法格式： abstract void add();抽象类里，无法被实例化，可以不包含抽象方法。但是，只要包含抽象方法的类必须被声明为抽象类。33. 接口 关键字 interface： 一个完全抽象的类（public interface Bird{//…}），只包含抽象方法 但是不需要用abstract关键字了： public void add();接口中，只能用 public修饰符，可以不写出，但是也会被默认为public,（变量都是 public static final的常量）接口可以被多实现，既 implements Interface1, Interface2{//…} 这就是为什么我们通常implements Runnable 而不是 extends Thread 来创建新的线程类了，如果你用了继承，就无法再继承别的了，但是接口可以多个。而且，一个接口类可以extends 多个其他接口类，只需要写出自己新的方法，实现的类需要实现以上所有接口的方法。实现接口的类里必须重写所有的接口中的方法实现接口的类可以向上转型成接口的类。当为了 1. 不让使用者创建新的对象（与抽象类同）2. 能够多实现接口时，应使用接口3. 如果确定一种类为基类时，最好是写成接口。补充： 接口经常被应用于‘策略设计模式’：1234567891011121314151617181920212223242526272829303132public interface Processor&#123; public String process(String s);&#125;public class Upper implements Processor&#123; public String process(String s)&#123; return s.toUpperCase(); &#125;&#125; public class Lower implements Processor&#123; public String process(String s)&#123; return s.toLowerCase(); &#125;&#125;//下面是应用， public class Test&#123; public static String applyPro(Processor p, String s)&#123; return p.process(s); &#125; public static void main(String[] args)&#123; print（applyPro(new Upper(), &quot;Dongdong&quot;)）； print(applyPro(new Lower(), &quot;Dongdong&quot; )); &#125; &#125; // 这样以来，在不同的applyPro 方法里就可以填入 Upper class或者 Lower class的对象，这样以来，就可以只用一个方法就灵活的策略一个String。34. 内部类，包括成员内部类，局部内部类，匿名（内部）类: 方便访问外部类的私有变量(能访问外部类的所有成员，当成自己的用)；12345678public class Test&#123; public String s = &quot;nihao&quot;; (public/private) class InnerTest&#123; //成员内部类,在方法里的交局部内部类 public void test()&#123; print(s); &#125; &#125;&#125;35. Java Collection框架，包括List,set,map等知识的总结单独开了一篇，后边整理数据结构可能会直接写进去： Java容器基础知识。36. 异常处理：好处，可以把异常机制和业务机制分离，不用让开发人员人为的把所有可能出错的地方都考虑进去。当Java程序出现以上的异常时，就会在所处的方法中产生一个异常对象。这个异常对象包括异常的类型，异常出现时程序的运行状态以及对该异常的详细描述。异常分类作为程序员，我们只需要手动写明可能出现的，可以预计的checked exception（编辑器会提示你）:,对于runtime exception我们只需要用if-else去避免try,catch,finally执行顺序：try - catch 2. 给对应的返回值赋值（但是还没有返回），一般finally里不要写返回值 3. 执行finally ，然后返回值，结束方法。37. String:String的对象是不可变的(每次一个新的值都储存在了常量池中)，每次修改其实是新建了一个对象（但是 StringBuilder类可以直接调用 append(), 所以当你需要对一个字符串多次叠加改变，用StringBuilder可以节省内存，如果编写toString方法，操作比较简单，用String好） StringBuilder 可以直接append(char c); append(String S); append(StringBuilder sb);常用方法：length();charAt();toCharArray();//把所有字符生成到一个数组里compareTo(); //按词典顺序比较indexOf();substring(0，3); // 注意string小写，当只填一个参数，代表从这个参数到最后的截取！！！concat(); // = + String 相加replace(”1“ ,“2”);//toLowerCase()// toUpperCase();trim(); // 去除两端的空白部分valueOf(); //其他类型转换成String;格式化说明符Formartter（用来修饰或者规范输出的格式，比如打印固定长度的字符串，或者控制小数点位数，日期，日历，打印出一个表格的形式等等，,同占位符组合使用）：格式:%[argument_index$][flags][width][.precision]conversion2 格式说明（1）argument_index$：指定对应的内容参数位置，默认按照顺序依次对应。（2）flags：格式控制。（3）width：区域宽度。（4）.precision：对于浮点型数据，表示显示的小数位数；对于字符串数据，表示显示的字符数量。（5）conversion：类型转换字符。当只需要规范一次，直接用String.format更方便。4.正则表达式：用于格式的匹配，比如看看输入的是否是一个邮箱的标准格式等等。常用：x 字符 x。举例：&apos;a&apos;表示字符a \\\\ 反斜线字符。 \\n 新行（换行）符 (&apos;\\u000A&apos;) \\r 回车符 (&apos;\\u000D&apos;) 字符类[abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） [0-9] 0到9的字符都包括 预定义字符类. 任何字符。我的就是.字符本身，怎么表示呢? \\. \\d 数字：[0-9] \\D 非数字:[^\\d]/[^0-9] \\w 单词字符：[a-zA-Z_0-9] \\W 非字符[^\\w]边界匹配器^ 行的开头 $ 行的结尾 \\b 单词边界， 就是不是单词字符的地方。 Greedy 数量词X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 运算符XY X后跟 YX|Y X 或 Y(X) X，作为捕获组补充：123456789 //1.split 方法： String str1 = &quot;1 2 3 4 54 5 6&quot;; String[] numbers = str1.split(&quot; +&quot;); //+号表示一个或者多个空格 for (String temp : numbers) &#123; System.out.println(temp); &#125;//2. replaceFirst(String s);// replaceAll(String s);39. RTTI（Runtime Type Information）和反射机制反射是动态语言的关键，在运行的时候才去确定执行具体方法的具体的类，让灵活度更高，代码更高效。40.JRE和JDK的区别：&nbsp;&nbsp;&nbsp;&nbsp; JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核\\心，包括了Java运行环境JRE、Java工具和Java基础类库。Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。41. 泛型类，泛型接口，泛型方法泛型的使用使我们的代码更加具有通用性，不会导致定义了一种类型之后其他的类型都无法使用该代码public staticT getLast(Listlist){return list.get(list.size()-1);} //这是一个泛型方法42.1234Class C1 = new ArrayList&lt;Integer&gt;().getClass();Class C2 = new ArrayList&lt;String&gt;().getClass)();//在这里 C1==C2， 因为在泛型应用的内部，或者说容器中，默认都是储存的Object,只不过在取出元素时又会自动为你向下转型为对应的类型。 另外，对于基本类型，容器中其实默认存入存出的是他们的包装类，只是也为你自动打包和拆包了。43. 数组： 是Java中效率最高的粗讯和随机访问对象引用序列的方式。（代价是大小固定，不能自由扩展。） 数组可以储存基本数据类型。“创建的三种方式：123456789101112131415161718192021222324252627//1. String[] array1 = new String[3]; array1[0] = &quot;ni&quot;; array1[1] = &quot;hao&quot;; array1[2] = &quot;ma&quot;;//2. String[] array2 = new String[]&#123;&quot;ni&quot;,&quot;hao&quot;,&quot;ma&quot;&#125;;//3. String[] array3 = &#123;&quot;ni&quot;, &quot;hao&quot;, &quot;ma&quot;&#125;; System.out.println(Arrays.toString(array1)+&quot;\\n&quot; +Arrays.toString(array2)+&quot;\\n&quot; +Arrays.toString(array3)); //4. 多维数组 int[][] a = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8&#125;, &#125;; System.out.println(Arrays.deepToString(a)); //多维数组用deepToString打印补充：数组本身是一个对象，在保存基本类型时时直接存入的值，在保存对象时，时保存的引用地址。实用方法：Arrays.equal();//判断两个数组的内容是否相同，Arrays.deepEquals();//多维数组Arrays.sort(array); //排序,是根据元素类型的 comparaTo();方法决定的大小。Arrays.sort(arrays,Comparator); //根据自己定义的Comparator类比较排序，自带一个Collections.reverseOrder();会返回整个序列的倒序。Arrays.asList();Arrays.toString(array);System.arrayCopy(); //数组的赋值，比循环快多了Arrays.binarySearch(arrays,element （，Comparator）);//只能用于已经排序好的数组,返回位置，如果没找到，返回 -插入点（第一个比查找的元素大的位置）-1。比较数组元素： 1. implements Comparable重写 compareTo()方法 2. implements Comparator，重写compare（Obj o1, Obj o2） 在Arrays.sort（array，Comparator）里使用。 Comaparator和Comparable都是接口，需要声明类型还有一个Static方法：12345678910111213141516 Comparator&lt;Student&gt; com = Comparator.Comapring(Student::getID).thenComparing(Studeng::getName).reverse(); ``` &lt;br&gt; 44.三个 转义符,(当做字符串插入进去就生效了)： \\n,\\t,\\r &apos;\\t&apos; 空格 &apos;\\r&apos; 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； &apos;\\n&apos; 换行，换到当前位置的下一行，而不会回到行首； &lt;br&gt; 45. 网络: 不过多阐述，github有几个简单的小项目可以去看 [Java,Tcp小练习](https://github.com/ShengdongYan/JavaNetPractice)，简单总结一下各个常用类： &lt;br&gt;InetAddress ; InetSocketAddressURLTCP: ServerSocket, SocketUDP: DatagramSocket DatagramPackeßt12345&lt;br&gt; 46. IO：&lt;br&gt; - File: 路径的推荐填写方式： String path = &quot;E:/demo/test/2.txt&quot;; // 如果用编译器，应该写成相对路径，&quot;src/demo1/2.txt&quot; 也就是从src开始写&lt;br&gt;String path = &quot;E:\\\\demo\\\\test\\\\2.txt&quot;; //Win下的，不能跨平台，写双\\\\是因为，单\\会转义 // 在其他平台没有盘符， 直接/demo/test/2.txt 代表了绝对路径 String path = String.format(&quot;E:%sdemo%stest%sni.txt&quot;, File.separator, File.separator,File.separator); //用File类自带的分隔符 String path = &quot;E:/demo/test/2.txt&quot;; //最推荐，可以跨平台 File src = new File(&quot;test.txt&quot;); //在当前工作目录下的文件（可以填写还不存在的，不会自动新建） //一下全都返回的String,或者boolean src.getPath();//只能得到相对路径， 如果上边写了盘符，就可以得到绝对路径 src.getAbsolutePath();//得到绝对路径 src.getParent();//如果填写的相对路径，只会返回空 src.exists(); // false src.canWrite();// false src.isFile();//判断是文件还是文件夹，但是如果文件不存在，会默认判断成文件夹。 src.isDictionary();// src.length();//返回大小，以字节数为单位B，只有文件才能这样读取！ //通常写法: String path = &quot;E:/demo/test/2.txt&quot;; File src = new File(src); if(!src.exist()){ boolean flag = src.createNewFile(); sout(flag? &quot;成功&quot;：&quot;失败&quot;); } src.delete（）; //创建目录： 必须保证父目录正确,或者直接连通父目录一起创建 String path = &quot;E:/demo/test/demo2&quot;; File src = new File(src); src.mkdir(); src.mkdirs(); //同父目一起创建 String[] fileNames = src.list();//返回子目录中的文件名称们 File[] files = src.listFile(); //返回子目录中的File 以对象形式，可以加filefilter来过滤文件或者文件夹 //想读取文件夹中的所有子文件，应该自己手写一个递归方法。 123456789101112131415161718192021222324252627282930313233343536- IO流: 以程序为中心，面向文件，数组，网络连接，数据库。 &lt;font color = green&gt; 出现读写乱码是因为编码集（字符跟字节的对应集合）不同，比如Eclipse是自动写出的JDK编码模式，但是计算机本身是以UTF-8模式,也有小部分原因可能是因为字符长度缺失&lt;/font&gt; 设定字符集的两种方式： String st = new String (&quot;字符串&quot;，“utf-8”);&amp;emsp;&amp;emsp;&amp;emsp;或者 byte[] data = &quot;中国&quot;.getBytes(&quot;utf-8&quot;); - 按照数据分类 - 字节流： 二进制文件，可以包括一切文件 - InputStream类： read(byte[] b) ; read(byte[] b, int offset, int len); +close; - OutputStream类： write(byte[] b) ; write(byte[] b, int offset, int len); +flush+ close(); //每次写都要手动flush一次，不然他自己是等缓存区满了才会推出； - 字符流： 只能处理纯文本 txt. - Reader类： read(char[] c); read(char[] c, int off ,int len);+ close - Writer类： write(char[] c); write(char[] c, int off,int len); write(String str, int off, int len); +flush()+close(); - 按照功能分类 - 节点流： 包裹源头 InputStream OutputStream FileInputStream FileOutputStream Reader FileReader/Writer - 处理流，增强功能，提供性能 - 字节流具体的操作： 1. 读取文件： 选择文件 - 选择流 - 操作（read,write）- 释放资源。 ``` File src = new File（E:/demo/test/2.txt）； InputStream in = null; // 增加可用范围 try&#123; in = new FileInputStream(src); byte[] car = new byte[10]; //读取数据的缓存区； int len = 0； //一次真实的读几到了多少byte while(1!=(len=in.read(car)))&#123; //当返回的长度是-1，表示没有数据了。 String info = new String(car,0,len); sout(); &#125; &#125; catch(IoExeption e)&#123; //... &#125; finally&#123; in.close(); &#125; 2. 写文件同理，只是记得 在 建立连接时 OutputStream out =new FileOutputStream(src,false); //false表示不覆盖原文件内容 !!，每次写要 flush();一次. 3. 拷贝文件 12345678910111213File src = new File（E:/demo/test/2.txt）；File des = new File（E:/demo/test/2.txt）；InputStream in = new FileInputStream(src);OutputStream in = new FileOutputStream(des);byte[] car = new byte[];int len = 0; //最大读取1024个每次while(-1!=(len=in.read(car)))&#123; out.write(car,0,len); out.flush();&#125;out.flush();out.close(); //规则先打开的后关闭。in.close(); 4. 拷贝文件夹，用递归，这里不详述&lt;br&gt; - 字符流具体操作：(txt .java等等) 节点流用Reader Writer / FileReader, FileWriter 1. 文件读取 123456789101112131415161718192021 File src = new File（E:/demo/test/2.txt）； Reader in = null; // 增加可用范围 try&#123; in = new FileReader(src); char[] car = new char[10]; //读取数据的缓存区； int len = 0； //一次真实的读几到了多少byte while(1!=(len=reader.read(car)))&#123; //当返回的长度是-1，表示没有数据了。 String info = new String(car,0,len); sout(info); &#125;&#125; catch(IoExeption e)&#123; //...&#125;finally&#123; try&#123; in.close(); &#125; catch()&#123;&#125;&#125; 2. 文件写出，同上只是写出时 ，也分追加和覆盖 String msg = &quot;锄禾/r/n日当/r/n午\\r\\n&quot;; wr.write（msg）; wr.append(&quot;再多写点什么&quot;); wr.flush(); - 处理流的具体操作： 1. 针对字节流： 字节缓冲流 BufferedInputStream 直接在节点流外边包一层缓冲流即可： BufferedInputStream in = new BufferedInputStream(new FileInputStream(src)); //输出流一样，也没有新增方法 2. 针对字符流： 字符缓冲流 BufferedReader 新增方法 readLine(); write.newLine();//等于/r/n 新建声明的时候同上，只是新增了方法 BufferedReader reader = new BufferedReader(new FileReader(src)); String line = null; while(null!=(line=reader.readLine())){ //.... } 对于从console输入 一般如下： BufferedReader console = new BufferedReader(new InputStreamReader(System.in)); - 转换流： 字节流转换为字符流： OutputStreamWriter 编码， InputStreamReader 解码。 常用方式： BufferedReader reader = new BufferedReader(new InputStreamReader(new FileReader(new File(path))), &quot;utf-8&quot;); //读取文件的常用写法 - Scanner 和 io的区别： java.util.Scanner类是一个简单的文本扫描类，它可以解析基本数据类型和字符串。它本质上是使用正则表达式去读取不同的数据类型。 Java.io.BufferedReader类为了能够高效的读取字符序列，从字符输入流和字符缓冲区读取文本,一般用于处理硬件输入，如键盘。 Scanner in = new Scanner(System.in); String s = in.nextline(); //或者nextInt(),等基本类型和String. in = new Scanner(new File(path)); //读文件 47. 程序（application），线程（thread），进程（process），CPU的关系：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统资源分配的基本单元，在传统的操作系统中（单核），进程既是基本的分配单元，也是基本的执行单元。在计算机中，一个进程就代表着一个程序，一个进程至少有一个线程，CPU如果是多核处理器，可以同时处理多个线程，就像常说的四核八线程（如果是单核处理器，只能处理一个线程，但是可以来回切换线程来处理不同的程序）。48. Javadoc ,comment注释:Javadoc是Java自带的一种工具，其可以从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。Java中有三种注释方法：//被注释语句/被注释语句//*被注释语句/ß其中第三种专为JavaDoc设计，可以被JDK内置的Javadoc工具支持和处理。49.注解： Annotation， (不同于 Comment),作用是1.生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等；2.跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；3.在编译时进行格式检查。如@Override放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出；而Comment只有注释生成文档的作用。（简单来说，一种是给人看的，一种是给机器看的）50. 多线程： 三种创建线程的方法：extends Thread 重写run();方法，调用 .start();启动线程 注意不调用run方法，因为start方法内部为run()方法单独声明了一个线程出来，而run方法本身只是普通方法，不是线程， 比如在main里，多个线程同时调用run(),他们还是只能按照普通方法执行完一个再执行下一个，但是调用start他们就可以实现多线程，交替被调用。implements Runnable(); 重写.run(); new 一个Thread作为静态代理， start 这个Thread 代理即可。 好处是， 1. 解决了Java单继承问题，把继承位空出来了 2. 资源贡献更方便，可以new多个代理，去处理同一个资源implements Callable; 使用比较麻烦，但是可以有返回值和跑出异常外部干涉一个线程通常通过调用该线程的内部方法，而不是直接改变该线程的值 如下：线程中的静态方法包括： Thread.sleep(); Thread.yeild(); Thread.interrupted(); Thread.CurrentThread();线程中断：interrupt中断机制中有如下方法：thread1.interrupt()，设置当前中断标记为true（类似属性的set方法）isInterrupted()，检测当前的中断标记（类似属性的get方法） //如果是阻塞状态，比如正在sleep, wait等等，这时interrupt的话会先把falge设置为 true, 抛出InterruptedException，马上又把falg设置为false,结束阻塞状态，继续运行Thread.interrupted()，检测当前的中断标记，然后重置中断标记为false,不管本来是false还是true（类似属性的get方法+set方法）因此interrupt中断机制并不是真正的将当前线程中断，而是一个中断标记的变化。所以，最简单的终止一个线程的办法就是在while里不断判断 if （isInterrupted()） break; 然后 在其他线程调用thread1.interrupt(),即可。下面的线程就是一种手动设置flag的办法。1234567891011121314151617181920212223242526272829303132333435 /** * @Author: ShengdongYan * @Date: 2019-04-21 * @Version 1.0 */public class ThreadTest &#123; public static void main(String[] args) &#123; Counter t = new Counter(); new Thread(t).start(); for(int i= 0; i &lt; 600; i++)&#123; if(i == 400)&#123; t.stop(); // 手动直接 t.flag = false没用，不能及时生效，除非flag设置为 volatile（让一个变量对多个线程可见）. &#125; System.out.println(&quot;i in the outer class is &quot; + i); &#125; &#125;&#125;class Counter implements Runnable&#123; int i = 0; boolean flag = true; @Override public void run() &#123; while (flag)&#123; System.out.println(&quot;i in inner class is &quot; + i++); &#125; &#125; public void stop()&#123; flag = false; &#125;&#125;下面是 Join()方法（意思是另一个线程加入进来，当前线程等待加入的线程执行完毕再执行）：1234567891011121314 public static void main(String[] args) throws InterruptedException &#123; Counter t = new Counter(); Thread thr = new Thread(t); thr.start(); for(int i= 0; i &lt; 1000; i++)&#123; if(i == 20)&#123; thr.join(); //意思是另一个线程加入进来，当前main()线程等待加入的线程执行完毕再执行 &#125; System.out.println(&quot;i in the outer class is &quot; + i); &#125; &#125;&#125;&emsp;&emsp; Thread.sleep(); 静态方法: 让当前线程进阻塞状态（挂起），不释放锁，常用于1. 跟时间相关，比如倒计时。 2。 模拟网络延迟; 在哪个线程里调用那个线程就停止，不是根据 线程明+sleep; 所以想要让另一个线程sleep也只能另一个线程的自己内部封装好什么时候sleep，而不是其他的线程写 名字.sleep(); 如果非要主动让另一个线程sleep,最好也通过调用改变flag的方法，然后让该线程自己调用自己的sleep方法。123456789101112131415161718192021222324class Counter implements Runnable&#123; int i = 0; boolean flag = true; @Override public void run() &#123; while (i&lt;1000)&#123; sleeping(); System.out.println(&quot;i in inner class is &quot; + i++); &#125; &#125; public void stop()&#123; flag = false; &#125; public void sleeping() &#123; try&#123; Thread.sleep(1000);&#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;Thread.yeild（） 方法， 让当前线程释放CPU资源进入就绪状态，等待重新分配资源， sleep()，是进阻塞状态，不释放锁，必须等待睡完，才能重新就绪； 而wait（）；是释放锁，也是进入等待状态，可以用notify()；或者notifyAll();唤醒线程优先级 最大值10 ，最小值1， 默认5， 有setPriority 和getPriotity方法）； 优先级不是绝对的先，是被调度的概率大51. 线程安全问题： synchronized修饰符：用来保证同一个资源被多个线程访问的安全问题，比如多个不同的Thread代理去代理同一个东西（携程，途牛，飞猪票），执行该方法或者代码块，必须先获得锁可以修饰，方法，可以修饰代码块。 修饰代码块必须加上对应的类锁。 （一般保证了线程的安全，代码运行速度会变低，所以修饰方位不能过大）， 修饰方法相当于用this当锁 ，推用this当锁，修饰static 方法时相当于用当前的 class对象当锁。死锁： 多个线程互相等待资源的释放。（就像是： A线程想要一手交钱一手交货，B线程想要一手交货一手交钱，两个人都在等待对方先释放自己所需要的锁，这样就进入了死锁）,所以要尽量避免在同步方法中调用其他对象的同步方法，经典解决办法：生产者消费者模式。（wait(),notify()+flag实现）；52. Stack和heap的区别总而言之： 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小（new了对象就分配），生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。JVM的内存结构栈中放： (局部的)八大基本数据类型的数据，方法参数和局部变量，对象的引用比如int a=3; int b =3;此时系统会先在stack创立reference (参照类型) a然后找有没有字面值为3的地址没有的话会自己创一个再将a指向它接着创造reference b ,看到有字面值3的地址就指向它改b = 4也不会删掉3这个字面值,系统会新增一个4的字面值在stack然后再让b指向它堆中放： 基本数据类型的包装类， new 的对象和其全局变量， final的局部变量关于String补充，code区放方法代码， data区放static变量常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。53. JUnit1.@Test: 测试方法a)(expected=XXException.class)如果程序的异常和XXException.class一样，则测试通过b)(timeout=100)如果程序的执行能在100毫秒之内完成，则测试通过2.@Ignore: 被忽略的测试方法：加上之后，暂时不运行此段代码3.@Before: 每一个测试方法之前运行4.@After: 每一个测试方法之后运行5.@BeforeClass: 方法必须必须要是静态方法（static 声明），所有测试开始之前运行，注意区分before，是所有测试方法6.@AfterClass: 方法必须要是静态方法（static 声明），所有测试结束之后运行，注意区分 @AfterassertEquals((message)，expected ,actual); 和 assertEquals(expected.equals(actual)); 都是判断两个值是否相等，但是第一种方法错误提示更全面，所以更常用54. 空间复杂度一般只看额外占用了多少辅助空间，（简单技巧就是看一共new了多少东西），循环中的 i虽然在变，但是默认只占用了一个辅助单元123456int a = 9;int b = 10;int c = 11; // O(1); //常数阶---------int[] i = new int[n]; // 空间复杂度为O（n）;54. 值传递和引用传递： Java是值传递（在方法内只是复制了一份数据值，不是传入的引用,传入引用的意思是，方法内所做的任何改变都会直接影响该对象的值），下面的方法可以证明在Java中，基本类型可以看成为值传递，如下：12345678int a = 10;void test(int a )&#123; a++;&#125;test(a); syso(a); //a的值没变，他只是在方法中复制了一份a,a本身不会变。这叫值传递当传入 引用类型时（除了基本数据类型的引用，都是引用类型）， 方法内部可以改变引用的对象的值。55. 并发编程中的：原子性，可见性,有序性，我们必须同时保证三个条件都满足，（用synchronized即可都满足，volatile,只能对变量使用，只能保证可见性）总结：原子性： 一个或者一系列的操作，要不连续不中断的执行完，要不不执行，或者不生效，也可以理解为一些列的操作是不能分割的（基本数据类型的赋值是自带原子性的，其他都不是，32位操作系统中的 double 和long不要具备，因为需要两步）可见性： 当数据发生变化，其他有关的线程立即知道有序性：Java允许编译器和处理器编译代码的时候进行 指令重排以达到优化的目的,这样以来无法保证多线程的代码执行顺序。56.defualt 关键字，来自Java1.8: 给接口加一个默认的实现方法，子类可以不重写，也可以重写。应用场景，当开发过程中，想给接口加一个新方法，如果按照以前的先写接口方法再在每个类都实现太麻烦，不如直接在接口中用默认实现。 defualt void add(){sout(“new method”);}57. Hashcode和hash方法的原理58.java生成唯一值的办法，1. 跟当前时间相关 2. 工具类 UUId.","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://dongdongyan.com/tags/Java基础/"}]},{"title":"Mybastis学习及使用笔记","slug":"Mybatis学习及使用笔记","date":"2019-06-02T22:34:50.000Z","updated":"2019-07-03T16:03:18.611Z","comments":true,"path":"2019/06/02/Mybatis学习及使用笔记/","link":"","permalink":"http://dongdongyan.com/2019/06/02/Mybatis学习及使用笔记/","excerpt":"","text":"概述Mybatis是一个优秀的基于 java的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement等繁杂的过程。mybatis通过 xml或注解的方式将要执行的各种 statement配置起来，并通过 java对象和 statement中sql的动态参数进行映射生成最终执行的 sql语句，最后由 mybatis框架执行 sql并将结果映射为 java对象并返回。采用 ORM思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api底层访问细节，使我们不用与 jdbc api打交道，就可以完成对数据库的持久化操作。为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。传统JDBC的不便：1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。2.Sql语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java代码。3.使用 preparedStatement向占有位符号传参数存在硬编码，因为 sql语句的 where条件不一定，可能多也可能少，修改 sql还要修改代码， 系统不易维护。4.对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo对象解析比较方便。WEB的三层架构：表现层(presentation)： 用于展示数据， 常见框架：SpringMVC ; (Spring框架对每一个都有涉及，不属于某一个)业务层(service)： 处理业务需求持久层(duration)： 和数据库交互 常见框架: MybatisJDBC持久层解决方案：传统JDBC：Connection+ PreparedStatement + ResultSetm（课件里有代码）Spring里的JDBCtemplate : 对JDBC简单的封装Apache的DButil: 对JDBC简单的封装阿里的durid: 数据库连接池MyBatis 好处：封装好了设置驱动，连接建立，语句书写以及执行等事物，让我们可以更专注于sql语句的编写。ORM思想： Object Relational Mapping: 对象关系映射， 简单的说就是把对象和数据库表练习起来，让我们操作对象就像操作数据库， 我们需要让实体类中的字段名和数据库中的字段名一致。Maybatis环境搭建步骤：Maven工程并导入坐标依赖创建实体类和Dao配置环境依赖：SqlMapConfig.xml配置映射配置，一个是针对每个Dao的 IUserDao.xml（针对每个Dao的mapper）配置时的注意事项mapper的位置目录结构要和Dao.java的目录结构一样mapper里的里 namespace里的值必须是dao接口的全限定类名mapper里的操作标签里的id取值要是Dao里的方法名遵从了这几点，就不用再写Dao的实现类","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://dongdongyan.com/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://dongdongyan.com/tags/Mybatis/"}]},{"title":"JavaWeb基础知识总结","slug":"JavaWeb基础知识总结","date":"2019-05-27T15:20:31.000Z","updated":"2019-06-23T18:22:33.656Z","comments":true,"path":"2019/05/27/JavaWeb基础知识总结/","link":"","permalink":"http://dongdongyan.com/2019/05/27/JavaWeb基础知识总结/","excerpt":"","text":"主要内容1. web相关概念 2. web服务器软件：Tomcat 3. Servlet入门学习 （三大组件，Servlet,Filter,Listener） 4. HTTP协议：响应消息 5. Request对象 6. Response对象 7. 用户登录案例 8. ServletContext对象 9. 会话技术 1. Cookie 2. Session 10. JSP：入门学习 11. Filter：过滤器 12. Listener：监听器 13. Redis 14. Maven web相关概念1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端: 好处，不用单独再开发客户端软件，维护简单，开发快速 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp.... 3. 网络通信三要素 1. IP：电子设备(计算机)在网络中的唯一标识。 2. 端口：应用程序在计算机中的唯一标识。 0~65536 3. 传输协议：规定了数据传输的规则 1. 基础协议： 1. tcp:安全协议，三次握手。 速度稍慢 2. udp：不安全协议。 速度快 web服务器软件：* 服务器：安装了服务器软件的计算机 * 服务器软件：接收用户的请求，处理请求，做出响应 * web服务器软件：接收用户的请求，处理请求，做出响应。 * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件： * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 * Tomcat：web服务器软件 1. 下载：http://tomcat.apache.org/ 2. 安装：解压压缩包即可。 * 注意：安装目录建议不要有中文和空格 3. 卸载：删除目录就行了 4. 启动： * bin/startup.bat ,双击运行该文件即可 * 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 * 可能遇到的问题： 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量 2. 启动报错： 1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 * netstat -ano 2. 温柔：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 5. 关闭： 1. 正常关闭： * bin/shutdown.bat * ctrl+c 2. 强制关闭： * 点击启动窗口的× 6. 配置: * 部署项目的方式： 1. 直接将项目放到webapps目录下即可。 * /hello：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\\hello&quot; path=&quot;/hehe&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录用来识别项目，意思就是，想进去这个文件，输入 localhost:8080/hehe/+资源名就好了,不写虚拟路径自动是设置成/ 3. 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\\hello&quot; /&gt; * 虚拟目录：xml文件的名称 * 静态项目和动态项目： * 目录结构 * java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet* 概念：运行在服务器端的小程序 * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 * 将来我们自定义一个类，实现Servlet接口，复写方法。 * 快速入门： 1. 创建JavaEE项目 2. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet 3. 实现接口中的抽象方法 4. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; * 执行原理： 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名 4. tomcat会将字节码文件加载进内存，并且创建其对象（反射） Class.forIstance(类名)。 5. 调用其 service()方法 * Servlet中的生命周期方法： 1. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt; -2&lt;/load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 * 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 * Servlet3.0： * 好处： * 支持注解配置。可以不需要web.xml了。 * 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 * @WebServlet(&quot;资源路径&quot;) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt; String[] value() default {};//代表urlPatterns()属性配置 String[] urlPatterns() default {};//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; } IDEA与tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件,用上边的第三种配置方式。 * 查看控制台的log：Using CATALINA_BASE: &quot;C:\\Users\\fqy\\.IntelliJIdea2018.1\\system\\tomcat\\_itcast&quot; 2. 工作空间项目 和 tomcat部署的web项目（在out里） * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源 * WEB-INF目录下的资源不能被浏览器直接访问。 3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动 HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接，新增了一个字段 host,用来指明ip地址，还有一个功能就是分割过大的message * 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan * 响应消息数据格式 Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext() Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); } } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中 ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同 会话技术1. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 2. 功能：在一次会话的范围内的多次请求间，共享数据 3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：Session Cookie：1. 概念：客户端会话技术，将数据保存到客户端 2. 快速入门： * 使用步骤： 1. 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2. 发送Cookie对象 * response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据 * Cookie[] request.getCookies() 3. 实现原理 * 基于响应头set-cookie和请求头cookie实现 4. cookie的细节 1. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;/&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 5. Cookie的特点和作用 1. cookie存储数据在客户端浏览器 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别 6. 案例：记住上一次访问时间 1. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime=2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime=2018年6月10日11:50:01 3. 代码实现： package cn.itcast.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; @WebServlet(&quot;/cookieTest&quot;) public class CookieTest extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0){ for (Cookie cookie : cookies) { //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name)){ //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; } } } if(cookies == null || cookies.length == 0 || flag == false){ //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } JSP：入门学习1. 概念： * Java Server Pages： java服务器端页面 * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 * 用于简化书写！！！ 2. 原理 * JSP本质上就是一个Servlet,收到请求后先看是否有对应的JSP文件，如果有就自动转换为Java文件并编译运行转换成Servelet类，类中一直自动写response.write(&lt;html&gt;信息)。 3. JSP的脚本：JSP定义Java代码的方式 1. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 4. JSP的内置对象： * 在jsp页面中不需要获取和创建，可以直接使用的对象 * jsp一共有9个内置对象。 * 今天学习3个： * request * response * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前 5. 案例:改造Cookie案例 Session：主菜1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 2. 快速入门： 1. 获取HttpSession对象： HttpSession session = request.getSession(); 2. 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 3. 原理 * Session的实现是依赖于Cookie的。 4. 细节： 1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 5. session的特点 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据 * session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 Filter：过滤器1. 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门： 1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 2. 代码： @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } 3. 过滤器细节： 1. web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下边的代码 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次， 一般在方形之前执行对Request的东西，在放行后执行对response的操作 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 4. 案例： 1. 案例1_登录验证 * 需求： 1. 访问day17_case案例的资源。验证其是否登录 2. 如果登录了，则直接放行。 3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。 2. 案例2_敏感词汇过滤 * 需求： 1. 对day17_case案例录入的数据进行敏感词汇过滤 2. 敏感词汇参考《敏感词汇.txt》 3. 如果是敏感词汇，替换为 *** * 分析： 1. 对request对象进行增强。增强获取参数相关方法 2. 放行。传递代理对象 * 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 Listener：监听器* 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; 2. 注解： * @WebListener Redis概念下载安装命令操作数据结构持久化操作使用Java客户端操作redis概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } } 案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://dongdongyan.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://dongdongyan.com/tags/JavaWeb基础/"},{"name":"Servlet","slug":"Servlet","permalink":"http://dongdongyan.com/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://dongdongyan.com/tags/Tomcat/"},{"name":"Cookie","slug":"Cookie","permalink":"http://dongdongyan.com/tags/Cookie/"},{"name":"Filter","slug":"Filter","permalink":"http://dongdongyan.com/tags/Filter/"},{"name":"Linsener","slug":"Linsener","permalink":"http://dongdongyan.com/tags/Linsener/"},{"name":"Request","slug":"Request","permalink":"http://dongdongyan.com/tags/Request/"},{"name":"Response","slug":"Response","permalink":"http://dongdongyan.com/tags/Response/"}]},{"title":"Java1.8 Lambda表达式+Function+Stream","slug":"Java1.8 Lambda表达式+Function+Stream","date":"2019-05-15T21:41:02.000Z","updated":"2019-05-31T22:52:34.621Z","comments":true,"path":"2019/05/15/Java1.8 Lambda表达式+Function+Stream/","link":"","permalink":"http://dongdongyan.com/2019/05/15/Java1.8 Lambda表达式+Function+Stream/","excerpt":"","text":"自Java 8 (JDK1.8) ，推出了几个新的重要特性，这篇博文主要介绍了 Lambda，Function,Stream这三个新特性的概念，意义，实际应用等。1. Lambda表达式：只有函数性interface接口才能用:java.util.function中包含了六个基础的 functiinal interface: Consumer, BinaryOperator,Function, Predicate,Supplier,UnaryOperator.Interface里只能有一个抽象方法。 如果要加其他方法，加 default void test(); 或者其他方法来自于Object 如toString(); (其实是为了在调用时为了让系统知道哪个方法被调用了) 。 在调用实现这个接口的类来运行该方法时，可以直接把方法当做一个参数去操作，省去实现类，提升了代码的整体性，简洁性等。12345678910111213141516171819202122232425262728293031323334Runnable a = new RunnableThread(&quot;一个实现了runnable接口的类&quot;);new Thread(a).start(); //这是一种常规的线程声明和运行办法// 匿名类的实现方法如下： new Thread(new Runnable() &#123; @Override public void run() &#123; Thread.sleep(1000); &#125; &#125;).start();//下面是Lambda表达式的方法,只要一行解决。// 1. statement方式，只有一句要执行的内容， 如果是有返回值的方法，不用写return， 自动识别 new Thread(()-&gt;System.out.println(&quot;Lambda&quot;) ).start(); //2. 语句块的模式，多句语句用&#123;&#125;包裹，如果有返回类型， 要写return；MyInterface interface = (String S, String SS) -&gt; &#123; System.out.println(&quot;接口省去写实现类&quot;); System.out.println(&quot;接口中的唯一方法名为test&quot;); System.out.println(&quot;接口中的方法具体这样实现重写&quot;); System.out.println(&quot;在1.8之前通常用匿名类的方式写&quot;); System.out.println(&quot;下面是这个方法的返回值&quot;); System.out.println(&quot;然后是调用&quot;); return SS；&#125;sout(interface.test()); // 或sout(interface::test);//3. 还有一种就是方法引用 ,用：：代替函数的调用 比如 Student.getName(); 等于Student::getName; 作为最为输入参数传入接口的方法，类型要一致, 相当于Lambda表达式的简写模式。MyInterface interface = String::new; (test 方法需要一个String,作为输入参数）；interface.test(“nihao”);2. Function接口： 把逻辑和业务分开，单独在需要用的时候写明需要具体执行的业务，更加灵活；Function&lt;T,R&gt; T是输入类型，R是要返回的类型！！！！！！！！！！！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546//下面是一般应用public Static Integer testFunction(Function&lt;Integer, String&gt; fun, String S)&#123; return fun.apply(S); &#125;// 调用时 testFunction(S-&gt;String.valueOf(S), &quot;123&quot;);-------------------------------------------------------------------------// 下面是经常用于处理Collection容器的完整例子public class LambdaTest &#123; List&lt;Apple&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;Apple&gt; filtApple(Predicate&lt;Apple&gt; predict)&#123; ArrayList&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: result)&#123; if(predict.test(apple))&#123; result.add(apple); &#125; &#125; return result; &#125; class Apple&#123; String name; int id; String Color; &#125; public static void main(String[] args) &#123; LambdaTest test = new LambdaTest(); test.filtApple(a-&gt;a.name.equals(&quot;ChineseApple&quot;)); test.filtApple(a-&gt;a.Color.equals(&quot;red&quot;)); // 这样就不用对每一种筛选条件都写一个接口了 &#125;&#125;Stream: 对集合进行遍历等操作，性能得到优化自己不储存对象不改变源对象，只返回一个新的Stream延迟执行，等到结果才执行,整个Stream其实只遍历了一次ArrayListlist = new ArrayList&lt;&gt;();list.stream.forEach(System.out::println);list.stream.forEach(a-&gt;System.out.println(a.getColor());Comparatorcomparator = Comparator.comparing(Apple::getName).thenComparing(Apple::getName).reversed();应用总结：12345678910111213141516171819202122232425262728293031323334//排序//第一阶段匿名类 ArrayList&lt;Apple&gt; list = new ArrayList&lt;&gt;();Collections.sort(list, new Comparator&lt;Apple&gt;()&#123; @override public int compare(Apple a1, Apple a2)&#123; return a1.getID()-a2.getID(); &#125;&#125;);////第二阶段 lambadaCollections.sort(list, (a1, a2)-&gt; a1.getID()-a2.getID());//第三阶段 StreamArrayList&lt;Apple&gt; newlist = list.stream.sorted((a1, a2)-&gt; a1.getID()-a2.getID()) .collection(Collectiors.toList());//过滤//过滤一个容器，上边2。中关于Function的代码是第二阶段//第三阶段Stream Map&lt;String S, List&lt;Apple&gt;&gt; groupedMap = list.stream.filter(a-&gt;a.name.equals(&quot;ChineseApple&quot;)) .filter(a-&gt;a.Color.equals(&quot;red&quot;)) .sorted((a1, a2)-&gt; a1.getID()-a2.getID()) .reversed(); .forEach(System.out::println); .collection(Collectiors.groupingBy(Color); //按照颜色分类返回一个map","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Lambda表达式，JDK1.8，Function,Stream","slug":"Lambda表达式，JDK1-8，Function-Stream","permalink":"http://dongdongyan.com/tags/Lambda表达式，JDK1-8，Function-Stream/"}]},{"title":"数据库基础知识笔记","slug":"数据库基础知识笔记","date":"2019-05-08T21:41:02.000Z","updated":"2019-06-28T15:53:23.216Z","comments":true,"path":"2019/05/08/数据库基础知识笔记/","link":"","permalink":"http://dongdongyan.com/2019/05/08/数据库基础知识笔记/","excerpt":"","text":"我个人对数据库学的比较浅，这篇博文记录了一些数据库的基础知识，主要用于个人笔记形式目录数据概念（脏读，幻读，不可重复读）事物四大特性 ACID数据库隔离级别隔离级别三范式1.数据概念（脏读，幻读，不可重复读）脏数据所指的就是未提交的数据。也就是说，一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，而事务在两次读取之间该数据被其它事务所修改，则两次读取的数据不同，我们称之为不可重复读。幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。2、数据库事务的四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）原子性：事务包含的所有数据库操作要么全部成功，要不全部失败回滚一致性：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。隔离性：一个事务未提交的业务结果是否对于其它事务可见。级别一般有：read_uncommit，read_commit，read_repeatable，串行化访问。持久性：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。3、数据库的隔离级别请看原文，原文出自4. 三范式表的三范式，加函数依赖简单总结：一范式 1NF： 普通的表都是符合第一范式的，也就是每一列都是一个单独的有意义的列，不是某个大列的子列，比如，不能有一个列（课程），下面又有（数学，语文，英语）。但是这种普通的一范式表有四种常见的问题：冗余（data redundancy 或者说聚合异常 arregation anomaly）: 表里有很多重复出现的数据，比如 （studentID, name , class，course , mark ）; 每个name 和id对于每一门课都要重复一次。插入异常（insertion anomaly）: 如果学校新开了一门课，但是当还没有学生注册的时候就没法加，因为没有主键；更新异常（update anomaly）： 如果把class更新，需要把所有其他相关的三行都更新才行。删除异常（delete anomaly）； 比如小明毕业了，但是小明的信息没法删除，因为主键删除的话，可能其他的班级之类的信息就无法继续保存了，这个班级信息可能就丢失了；所以才涉及到分表解决问题， decomposition二范式 2NF：每一个非主键的元素都完全函数依赖于候选键（candidate key）;完全函数依赖: 如现在有属性集U =（x,y,z）， 和属性（或属性集）: n； n只能由 x,y,z这三个元素共同函数决定，不能依赖于任何真子集，如 (x),(x,y),(y),(z),(x,z)等；上边的姓名就是部分依赖于SID，不用course来决定；根据函数依赖分表解决即可，让分出来的子表都各自依赖于自己的候选键二范式解决了数据冗余和更新异常，没解决删除异常和插入异常；候选键(candidate key）： 最小的能决定表中其他元素的集合，如上边学生的例子中， （studentID,course）一起可以决定其他所有的元素，候选键可以为多种情况。 如： A-&gt;B， B C -&gt;E , E D-&gt;A; 候选键就可以是： BCD或ACD或CDE。主属性： 所有candidate key里的属性都是；如上边的例子， ABCDE全是主属性！主键（primary key ）： 用户自己选定的属于candidate key的真子集超键（super key）： 候选键+任意数量的非主键元素。也可以决定其他的元素了，因为主键自己就可以决定其他元素；外键（foreign key）: 在其他表是主键；三范式 3NF： 在二范式的基础上，不能存在对候选键是传递函数依赖； 比如 （SID，name , class, monitor）， SID可以决定其他所有元素，可以作为candidate，但是SID能决定monitor主要是因为 SID-&gt;class-&gt;monitor，而不是直接决定的。所以不符合要根据传递依赖拆分解决了所有四个一范式的问题BCNF： BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。 任何属性都不能有传递依赖和部分依赖；比第三范式更严格，第三范式之前一直都是对非主属性说不能有传递依赖和部分依赖，BCNF是任何元素都。例子：123456789关系集U（S,T,J）中，S是学生，T是教师，J是课程。每一教师只教一门课，每门课有若干教师，某一学生选定某课程，就得到一个固定的教师。函数依赖：（S,J）决定T;（S,T）决定J;T决定J;这里候选码（S,J），（S,T）；不存在非主属性对码的部分或传递函数依赖，所以STJ属于第三范式；但是J部分函数依赖于码（T,S），不满足第2条，所以STJ不属于BCNF；分解： 一般先随便找一个函数依赖，把函数依赖里的几个元素放在一个表里，非函数依赖的+决定元素放一个表里再看是否符合BCNF，不符合就继续分解；看是否分解后 lossless, reduce redundancy, dependency preservinglossless, 字面意思，两个表合起来以后还原成一模一样的表，没有多余和减少； 直接判断方法： 如果（V,U，W）分解成（V,U）,(U,W) U是其中任意一表的candidate key 这次分解就会是无损的；如果不符合无损，就没必要往下判断了。 这个candidate key 可以是由本来给出那些FD的推导出来的redundancy reducing：如果按照第二二范式规范分解，即本来有部分依赖，针对该部分依赖单独分出了子表即可减少。如下题的a.ii是lossless and redundancy reducing 的,因为这是按照 B C -&gt;D分解, 这样以来相当于把A B C当成了 candidate key， 而 A B C对于D是部分依赖于B C，所以这样一来分解出了这个部分分解，就会是redundancy reducing的dependency preservng: 尽管把表分开了，但是各自能满足的 FD没变，比如上边的 ii 中， （A B D）&amp;&amp;(B C D)， (A B C) 可以还原满足三个FD中的 A B -&gt; C, (B C D) 可以满足 FD中的 B C -&gt;D 再通过 transitivity原则，可以得到 A B -&gt; D， 这样以来三个F D都还原了出来。下面是我自己mysql数据库使用过程中遇到的各种问题,大家可以忽略：本机的连接标准格式driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///travelusername=rootpassword=Yanshengdong123initialSize=5maxActive=10maxWait=3000可以在url行自己手动加端口号和地址String url = “jdbc:mysql://localhost:3306/mydatabase”；详见travel和test项目中的jdbc连接。 注意maven项目中添加数据库driver的版本要和本机的一致才行&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://dongdongyan.com/categories/数据库/"}],"tags":[{"name":"数据库三范式，事物四大特性，隔开级别","slug":"数据库三范式，事物四大特性，隔开级别","permalink":"http://dongdongyan.com/tags/数据库三范式，事物四大特性，隔开级别/"}]},{"title":"LeetCode刷题笔记","slug":"LeetCode刷题笔记","date":"2019-05-02T22:34:50.000Z","updated":"2019-05-14T10:29:10.381Z","comments":true,"path":"2019/05/02/LeetCode刷题笔记/","link":"","permalink":"http://dongdongyan.com/2019/05/02/LeetCode刷题笔记/","excerpt":"","text":"简介：Hash:Array：List:String：Stack；Tree:Queue:Graph:简介：在这里主要整理一下LeetCode的刷题笔记和数据结构总结，我计划先按照AC率刷50道练手热身，再按照标签刷；目前先按照类型整理, 格式： 类型 + 题号+ 笔记； 下一个题号+ 笔记；几种常见排序算法的复杂度：Hash:插入，查询，删除的效率都是O（1）； Java中的 loadfactor=0.75 = n/T; 所以复杂度是常数771 : 在各种数据结构中 hash的搜索查询速度是最快的 O（1）。具体来说: 是因为，在查询一个key时，会直接用对应的方法计算出对应的 hashcode和table里的位置，而table的底层是数组加链表，（1.8后当链表长度超过8，自动转化为红黑树）， 对于给定位置的查询Array无疑是最快的，所以hash用作查询最快.(hashset用于存单个的不重复的值，hashmap的value设成了null,hashtable比较慢。因为方法都加了sychronized保证安全);但是，这道题String的foreach更快，可能是因为查询的东西比较短，转化到hash的时间不太值。804 二十六个字母 从 a-z可以用加法 比如 char b = ‘a’++; b就是‘b’ ; 另外利用好Set可以自动剔除重复元素，就不用自己一个个判断了Array：807 ： 学会找二维数组纵向最大值投影和横向最大值投影（从上往下看，生成列的最大值数组，从左往右看生成行的最大值数组），也相当于学会了找行的最大值和列的最大值1234567891011int [][] d = &#123;&#123; 2, 3, 4&#125;,&#123; 5, 6, 7&#125;,&#123;24,25,26&#125;,&#123; 6, 7, 8&#125;&#125;;for (int[] element : d)&#123;for (int el : element)&#123;System.out.printf(&quot;%4d &quot;,el);&#125;System.out.println();&#125; // 遍历二维数组的方法654: 数组需要单次找最大最小时可以用下面的方法，但是如果不断的得到subarray或者递归时，最好还是自己手动写一个 int left 和 int right来记位置，当参数，每次递归就更新。三种找到数组中最大值的方法： 1. Arrays.sort(arr); 2. (int)Collection.max(Arrays.asList(arr); 3. Arrays.stream(arr).max().getAsInt();905+83： 为了减少空间复杂度，处理一个array时，比如翻转等操作，最好是在源数组做处理，从双向同时考虑，分析找规律，看怎么同时对两个方向处理，不然就得新建建一个其他的数组，存每次产生的数据，想不出来时果断新建一个数组，只要只遍历一次，时间复杂度都是一样的最小；List:String：对于经常改变的String,用StringBuilder更节省空间。 .toString(); new StringBuilder(String S); .append(String S);Stack；Tree: 学会合理用递归938 给出一个范围，找到该范围内BST所有node的和。 用recursion654 对于空输入想输出异常时，用IllegalArgumentException 或IllegalStateExceptionthrow new IllegalArgumentException(“deleteHB: value is not in the tree”);Queue:Graph:##","categories":[],"tags":[]},{"title":"Java容器基础知识总结（Collection框架)","slug":"Java容器基础知识总结（Collection框架","date":"2019-04-14T20:07:48.000Z","updated":"2019-05-13T14:05:16.583Z","comments":true,"path":"2019/04/14/Java容器基础知识总结（Collection框架/","link":"","permalink":"http://dongdongyan.com/2019/04/14/Java容器基础知识总结（Collection框架/","excerpt":"","text":"这里目前主要先用来总结一下Collection框架的基础知识，包括各个容器的优劣，使用场景等等. 这篇博客里有很多地方我自己比较清楚的，就没有详细写注释，如果不清楚哪个地方可以自己查看下面的官方文档JDK1.8中文官方文档Collection框架接口：注意： Array不属于这个框架里的类，应该用 Arrays.asList方法转化成list类型：12String[] strings = new String[]&#123;&quot;ni&quot;,&quot;hao&quot;&#125;;List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(strings));一些概述：在java.util.包中容器的打印无需任何帮助，其中的类都可以直接打印，Array想要打印就得先转换成List或者用 Arrays.toString（array）; 产生可打印表示。四大接口： Collection,Set,List,mapCollection接口的通用方法(衍生的类都自动有)：addAll(Collection c1, Collection c2); //把另一个collection子类的的元素并入第一里。Listlist = new ArrayList(Collections.nCopies(4,new Address()); // 用四个相同的address填充进去.add();.addAll(collection c);//或者 （index, Collection c）;.remove(index);.size();.isEmpty();.clear();.toArray();.containsAll(Collection&lt;?&gt; c );.contains();.iterator();工具类 Collections（这是一个类，不要与Collection接口搞混）,方法介绍。Collections.fill(list, address1); //用指定的元素代替指定列表的所有元素。 Collections.copy(list,list2); //用两个参数，一个目标 List 和一个源 List, 将源的元素拷贝到目标，并覆盖它的内容。目标 List至少与源一样长。如果它更长，则在目标 List 中的剩余元素不受影响。 Collections.nCopies(4,new Address()); Collections.reverse(Collection c);//逆序一个容器的内容，可加 ,Comparator或者在自定义类实现Comparable接口； Collections.shuffle(Collection c);//乱序 Collections.sort(Collection c); //可加 ,Comparator或者在自定义类 实 现Comparable接口； Collections.binarySearch(Collection c, E element);//可加 , Comparator或者在自定义类实现Comparable接口； Collections.frequency(list, s);//检查一个元素出现的频率，可以先把list的东西存入set（自动消除重复，在依次用这个方法可得到每个元素的出现次数）, TreeSet&lt;Student&gt; students = new TreeSet&lt;Student&gt;( new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return o1.getName().compareTo(o2.getName()); } }); 1. List 有序可重复, 实现类：ArrayList: 擅长随机访问元素（ get(i)），但在List中间插入和移动元素很慢,线程不安全，一般使用； 源码，底层是数组，每次扩展变成1.5倍容量，默认长度是10。List&lt;String&gt; slist = new ArrayList&lt;&gt;(Arrays.asList(&quot;wo&quot;,&quot;hao&quot;,&quot;ma&quot;)); slist.add(element); slist.add(index, element); //也可以加位置，来插人固定位置。 slist.get(0); slist.remove(); slist.clear()//清空； slist.size(); slist.contans(&quot;ni&quot;);//返回boolean，判断是否存在，会根据元素类 .equals（）方法判断，基础知识篇已经讲过。 slist.indexOf(“h”); //根据equals()方法先判断存在，再返回位置，如果没有返回-1； .containsAll(); //判断是否包含了另一个ArrayList的所有元素，顺序不重要。 .subList(1,2); //截取一个新的，老的不影响。 .removeAll(); // 也是根据equals()方法。 .retainAll(list1,list2); //交集 .toArray(); .set(位置,元素 )； //替换 .addAll(int index, Collection&lt;? extends E&gt; c);//指定位置插入 LinkedList: 在List中插入和删除很快，优化了顺序的访问，但是在随机访问方面很慢,线程不安全。（Java 中是双向的，doublelinkedlist）//因为同时也实现了Queue接口，所以也有peek，poll,方法peek();getFirst(); //= element(); 返回第一个元素，如果为空会报错，但是 peek（）；在为空会返回null;peekFirst();//返回peekLast();pollFirst();//返回并移除removeFirst(); // = remove(); poll();addFirst();// =add(); 在最后 addLast();removeLast();// 返回并移除；Vector: 底层，array， 线程安全，效率低，相当于ArrayList中的方法都加了Synchronized。2. Stack(栈)：底层是数组 ,继承自Vector类，Vector继承自AbstractList。 但是一般我们利用ArrayList或者LinkedList自己重写实现一个属于自己的Stack类Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(9); LIFO，peek（）；// 得到最上边的元素却不推出pop();//返回并推出3. Set不保存重复的元素（add新元素不会报错，还是只剩一个），无序，可以有一个为空的元素，最常用到的地方是测试归属性，可以很容易的查到某个对象是否在set中，长处就是快速查找。 contans(); 没有新增方法，方法同Collection1234567//读取一个文件中的单词： Set&lt;String&gt; words = new TreeSet&lt;String&gt;( new TextFile(&quot;SetText.txt&quot;, &quot;\\\\W+&quot;)); //意思是把 .txt文件里的内容按照 正则表达式断开为单词元素，并传入 一个set. //或者直接传入一个其他的collection，自动去去除其中的重复项。Set&lt;String&gt; set = new HashSet&lt;&gt;(Collectiion&lt;String&gt; C);HashSet: 底层是用的HashMap实现的，只是把Value都设成了同样的固定值(一个空的Object)。TreeSet: 简化版的TreeMap, 底层是TreeMap.不是基本类型的话需要自己重写compareTo(),不用重写 equal方法了，如果compareTo判断是同一个就自动不存进去。4. Map专用于解决储存映射关系，或者对应关系的问题。 HashMap擅长快速查询和访问，TreeMap会自动排序keys,LinkedHashMap保证了插入的顺序。（同对应的set.） 键不能重复，value可以重复。, map 不方便遍历，一般遍历的方法是先得到 .keySet();,再利用这个set进行操作，如想遍历打印一个map时12345678Map&lt;String, String&gt; map= new HashMap&lt;String,String&gt;();get(key);// 返回对应的value,put(key,value);// 如果有，就更新valueputAll(map);containsKey(key);containsValue(value);keySet(); // 返回set形式的keysvalues();// 返回Collection形式的values; HashMap: 底层是数组加（单向）链表，当链表长度大于8，自动变成红黑树，这样查询的速率又提高了。 （允许存入空的 key和value）如果要加入同key的，会更新value。通过key,读取value的过程：先通过key的hashcode取得key的hash()返回值，然后找到对应的链表，一个个开始对比key的eual方法。 （有时候hashcode可能会相同，但是不 ==。但是如果 equal，哈希值就相同，就是相同）扩容，当数组内容超过 0.75，自动 System.arrayCopy（）到容量2倍的新数组。TreeMap: 需要在MAP里排序的时候用，底层是用红黑二叉树，存入后自动排序。基本类型自带了Comparable，不是基本类型的话需要自己重写compareTo(),不用重写 equal方法了，如果compareTo判断是同一个就自动不存进去;HashTable: 底层与hashmap几乎一样，只是加了很多synchronized,保证了线程安全，效率相对低。不允许key 和value为空。5. Queue (是个接口) 双端队列Deque是其子接口（可以从双端插入可取出）。FIFO: 常用语将对象从程序的某个区域传到领一个区域的途径。作为List使用时,一般采用add / get方法来 压入/获取对象作为Queue使用时,才会采用 offer/poll/take等方法1. Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); offer(); //插入队尾，或者返回false； peek（）；// = element（）；在不删除的情况下返回队首 poll(); // remove(); 在移除的情况下返回队首； 他们的共同之处是建议实现类禁止添加 null 元素，否则会报空指针 NullPointerException； 不同之处在于 add() 方法在添加失败（比如队列已满）时会报 一些运行时错误 错；而 offer() 方法即使在添加失败时也不会奔溃，只会返回 false。 优先级队列： Dequeue:.addFirst();.addLast();.pollFirst();.pollLast();PriorityQueue:其实是一个堆PriorityQueuepriorityqueue = new PriorityQueue(); //自动排序， 你可以通过Comparator修改。.offer(); //加入元素.peek();// 返回头但是不移除.poll();//返回头并移除.remove(object o);//移除元素如果包含12345PriorityQueue&lt;String&gt; prique = new PriorityQueue&lt;String&gt;(10,new Comparator&lt;String&gt;&#123; public int compare(String s1,String s2)&#123; return s1.compareTo(s2); &#125;&#125;); 6. Iterator(迭代器):Java中的迭代器只能单向移动，Collection接口已经implements Iterable接口了，所以只能：1234567891011121314151617181920212223241. .iterator()方法返回该容器的Iterator Iterator&lt;String&gt; it = slist.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;2. next();3. hasNext();4. remove(); //注意这里移除的是 next()返回的最新元素（或者说访问过的最后一个元素）， 不是调用next()后的下一个元素。 **如果只打算遍历，不打算修改，foreach是更好的选择**5. ListIterator 是专门为ArrayList设计的，功能更强，可以访问前一个元素的和后一个元素的索引，还有set方法。6. 对于Map,因为不属于Collection下面，所以有两种方式 1. Set&lt;Entry&lt;E key, E value &gt;&gt; = map.entrySet(); 在循环里再 Entry&lt;E key, E value &gt; = iterator.next();得到每一个元素。 2. 对于Map,可以keySet(), (valueSet());分别得到keyset,再进行遍历7. 容器中的泛型泛型的底层相关是擦除的知识，在存入时所有具体类型的信息都会被忘记12Class C1 = new ArrayList&lt;Integer&gt;().getClass();Class C2 = new ArrayList&lt;String&gt;().getClass)();//在这里 C1==C2， 因为在泛型应用的内部，或者说容器中，默认都是储存的Object,只不过在取出元素时又会自动为你向下转型为对应的类型。 另外， 对于基本类型，容器声明的时候的类型只能是其包装类，因为基本数据类型不是一种类。 所以用 Arrays.asList(array); array的类型也不能为int等，不然识别不了。 但是.add(10); 可以写入int,会发生自动拆包和封箱（当int作为唯一参数传入一个要求是integer的方法时会发生，其实相当于 arrayList.add(Integer.valueOf(100));）。8. 应用场景经典应用，打印表格， 一般表格可以有两种存取方法：List+Map(表格的头当做不同的Key,对应的每个值当做value，然后Map存入ArrayList)List+自定义内部类","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Java基础， Collection框架，Java容器","slug":"Java基础，-Collection框架，Java容器","permalink":"http://dongdongyan.com/tags/Java基础，-Collection框架，Java容器/"}]},{"title":"SE-UML图类总结","slug":"SE-UML图类总结","date":"2019-04-13T21:41:02.000Z","updated":"2019-04-29T17:17:45.264Z","comments":true,"path":"2019/04/13/SE-UML图类总结/","link":"","permalink":"http://dongdongyan.com/2019/04/13/SE-UML图类总结/","excerpt":"","text":"最近有场Software Engineering考试，趁机总结一波各种UML图的画法，包括UserCase, State, Activity, Sequence, FirstCut Diagram 等等1. Usercase Diagram（用例图）基本元素：用例图中包含6个元素，分别是执行者（Actor），用例（Use Case），关联关系（Association），包含关系(Include)，扩展关系(Extend)以及泛化关系(Generalization)。如何选Actor:1234567891）有哪些直接使用系统的人2）涉及到哪些维护人员3）使用哪些外设4）相连的其他系统5）还有哪些人和事物对这个系统产生的结果感兴趣。《include》 关键字：主要有以下两种情况需要用到包含关系。多个用例用到同一段的行为，则可以把这段共同行为单独地抽象成一个用例，然后让其他用例来包含这一用例。当某一个用例功能过多，事件流过于复杂时，也可以把某一段事件流抽象成一个被包含的用例，以达到简化描述的目的。《extends》 关键字在一定条件下，把新的行为加入到已有的用例中，获得的新用例叫做扩展用例总结： Usercase Diagram 就是先找出几个可能的actor,然后先只画出主要的活动，在用 include 或者extends扩展活动。Activity diagram(活动图)if-else（或）表示：并发、并行表示：例子：This figure below describes the business process for meeting a new client using an activity Diagram with swinlane.总结： 主要是符号别用错，分好大的区间Partition，一个对象一个区间，每个区间里的行为都是由该对象作出的。Class Diagram关系; 关系的详解记住下面的图即可，一般只会用到关联，组合，聚合。数量关系：总结： 这次考试大概只需要写First cut，看看课件的例子比较好Sequence Diagram详细介绍：提示： 控制焦点两端要以消息元素封顶，控制焦点不要超过消息元素。State diagram课件很详细，这随便上个例题Component Diagram","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://dongdongyan.com/categories/计算机基础知识/"}],"tags":[{"name":"SE","slug":"SE","permalink":"http://dongdongyan.com/tags/SE/"},{"name":"UML","slug":"UML","permalink":"http://dongdongyan.com/tags/UML/"}]},{"title":"Java问题汇总","slug":"Java面试准备","date":"2019-04-12T21:41:02.000Z","updated":"2019-05-14T22:22:12.311Z","comments":true,"path":"2019/04/12/Java面试准备/","link":"","permalink":"http://dongdongyan.com/2019/04/12/Java面试准备/","excerpt":"","text":"这里记录一些常见的问题以及答案，主要是针对Java面试。有用的必备链接：知乎专栏牛客网github面试专刊常用资源都在这里：一 多线程问题死锁的概念，以及会写死锁小程序。（多个线程互相锁也是死锁的一种）在A线程正在执行一个对象中的同步方法，B线程是否可以同时执行同一个对象的非同步方法可以，跟下边的题一样，只要不是非同步都随便走。在同一个类中，当其中的同步方法执行时，可以执行另一个非同步方法吗？可以，非同步的方法可以再该线程或者其他线程执行，没有影响在一个同步方法中可以调用同一个类中的另一个同步方法并顺利执行吗？可以 ，同一个线程，同一个锁，可以顺利执行程序执行过程中，如果同步问题出现异常，锁会被释放吗？会的，所以要多加小心，如果不想释放，加try catch做出处理volatile关键字和synchronized的区别。volatile比较快，轻量级。保证了线程间，内存的可见性，如果不用volatile，就得上sychronized,来保证资源的调度一致性。（但是volatile只保证了可见性，syhcronized既保证了可见性，又保证了原子性，不能用volatile代替syncronized,当我们只需要保证可见性时才用volatile）AtomXXX类跟sychronized比为什么更高效？更上边一样，为了提高效率。 保证了调用的方法原子性，做一些常见的加减很好用。但是，不能保证多个方法的连续调用还有原子性（其他线程可能会进来操作）。比如银行账户系统，只同步set(); 不同步get行不行（）； 不行，因为就算set（）；每次只能被一个线程用，其他线程很有可能在set执行的过程中，不断的读取，还是会出错。Java SE(Java Platform,Standard Edition)，应该先说这个，因为这个是标准版本。Java EE (Java Platform，Enterprise Edition)，java 的企业版本。 JavaEE在JavaSE的基础进行了扩展，增加了一些更加便捷的应用框架。比如我们现在常用的Java开发三大框架Spring、Struts和Hibernate，我们可以应用这些框架轻松写出企业级的应用软件。Java ME(Java Platform，Micro Edition)，java的微型版本。","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Java问题","slug":"Java问题","permalink":"http://dongdongyan.com/tags/Java问题/"}]},{"title":"机器语言的分类（高级，低级，动态，强类型，,编译型，解释型，面向对象等等）","slug":"机器语言的分类","date":"2019-04-08T14:13:13.000Z","updated":"2019-05-22T13:33:23.338Z","comments":true,"path":"2019/04/08/机器语言的分类/","link":"","permalink":"http://dongdongyan.com/2019/04/08/机器语言的分类/","excerpt":"","text":"计算机语言的几种分类常见的几种分类高级语言和低级语言动态类型和静态类型强制类型和弱类型编译型，解释型，半编译半解释（附编译器解释器）面向对象型和面向过程型1. 高级语言和低级语言常见的低级语言有：机器码、汇编语言(assembly language)高级语言常见如：c，c++，java，python，PHP，c#，Ruby，go，kotlin，swift。机器码：计算机能够直接识别的二级制编码，无论语言多高级都要转成二级制文件来让计算机识别运行。汇编：用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，在不同的设备中有着不同的指令集下面是一个LMC的例子：(little man language)12345678910111213INPSTA AL OUTADD ASTA BSUB CBRP ELDA BBRA LE HLTA DATB DATC DAT 100高级语言：为省去编程时候的不必要的操作细节，节省代码量，可读性强，维护性强，更贴近人性化高级语言与低级语言的区别：高级语言大部分不能直接更硬件打交道，这使得相对来的程序运行速度降低，总之一句话来说那种语言更接近人性化的语言就更高级。2. 动态类型和静态类型动态性语言是指在程序运行期间才给变量指定数据的类型，（数据类型可以根据环境改变） 常见于Object-C、C#、JavaScript、PHP、Python、Erlang等，而静态类型语言则恰好相反，在写程序代码的时候就要指定变量的类型，这种语言有：c，c++，java3. 强制类型与弱类型我们可知C语言中，一个变量只能定义为一种类型，如float类型，那么它就只能是float类型而不能在不发生转化的情况下赋予int类型，这就是 强制类型 的具体体现。而python和js不是，python中的变量可以任意的复制，而没有类型的界限。这就是弱类型强制类型更严谨，更不容易出现错误，但弱类型的语言写起来更优雅，更舒畅4. 编译型，解释型，半编译半解释对于源程序，编译型语言在执行程序中会将源文件一次性的转化为机器码，而解释型语言是边编译边解释；解释型语言是离不开解释程序的，这也导致了解释性语言对于运行时候的速度比价慢，解释型语言只要有解释器，移植起来比较方便，而编译型语言则要对于不同的系统进行编译，是的工作繁琐，且在调试程序的时候比较慢编译型语言可见于c，c++等解释型语言可见于python，JavaScript，Perl，shell等而java和c#是半编译半解释型的语言，java会将源文件在jVM中转化为字节码，即.class文件，在程序运行的时候转化为二进制文件。和C#中的.net有点区别，C#编译的成的.net目标代码（中间码），接近与二进制文件，可移植性没有java好，java是“一次编译，到处执行”，c#是“一次编码，到处编译”。补充： 编译器和解释器编译器（compiler）：把高级语言编译源码一次性成机器码供计算机阅读，好处就是方便和快速解释器（interpreter）:而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的. 编译器和解释器在执行操作前都会检查代码的正确性对于Java,是先由编译器javac.exe编译成中间码（相当于JVM的机器码），JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。5. 面向对象型和面向过程型面向过程是决定该怎么铺成一条路到达终点，而面向对象是要用那些具有特定功能的像来做，两者是不同的思想。c++是部部分面对对象的，java具有封装性是完全面对对象的，c语言是面对过程的语言","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://dongdongyan.com/categories/计算机基础知识/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://dongdongyan.com/tags/计算机基础/"},{"name":"编程语言","slug":"编程语言","permalink":"http://dongdongyan.com/tags/编程语言/"}]},{"title":"写博客的Markdown语法介绍","slug":"写博客的Markdown语法介绍","date":"2019-04-07T20:19:15.000Z","updated":"2019-04-08T22:51:59.663Z","comments":true,"path":"2019/04/07/写博客的Markdown语法介绍/","link":"","permalink":"http://dongdongyan.com/2019/04/07/写博客的Markdown语法介绍/","excerpt":"","text":"md语法已经成了程序员的一项必备技能作为程序员，学会用markdown文本编辑代替传统的Office全家桶才够酷。重要的是，写一些博文，甚至在网上发表评论的时候，md语法几乎是必备的。现在大部分的论坛和网站都已经默认支持了md语法，包括github，简书,csdn,博客园等等。以.md结尾的文件就是用markdown语法的地方了，推荐用VScode进行编辑，可以在编辑的同时直接在右侧预览效果。如下：所以，总之作为程序员，如果不会基本的md语法那你就out啦！md语法已经有很多成熟的介绍文章了，所以我直接引用了一篇比较基础的，也方便以后我自己复习下面是引用内容：一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。示例：123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题效果：这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体加粗要加粗的文字左右分别用两个*号包起来斜体要倾斜的文字左右分别用一个*号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来示例：1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容效果如下：这是引用的内容这是引用的内容这是引用的内容四、分割线三个或者三个以上的 - 或者 * 都可以。示例：1234-------********效果如下：五、图片语法：1![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加示例：12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)效果如下：上传本地图片直接点击导航栏的图片标志，选择图片即可六、超链接语法：1[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加示例：12[简书](http://jianshu.com)[百度](http://baidu.com)效果如下：简书百度注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例简书七、列表无序列表语法：1234无序列表用 - + * 任何一种都可以- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格效果如下：列表内容列表内容列表内容有序列表语法：数字加点123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格效果如下：列表内容列表内容列表内容列表嵌套上一级和下一级之间敲三个空格即可1234- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容效果一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容1234- 一级无序列表内容 1. 二级无序列表内容 2. 二级无序列表内容 3. 二级无序列表内容效果一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容123456781. 一级无序列表内容 1. 二级无序列表内容 2. 二级无序列表内容 3. 二级无序列表内容2. 一级无序列表内容 1. 二级无序列表内容 2. 二级无序列表内容 3. 二级无序列表内容效果一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容八、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略示例：12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟效果如下：姓名技能排行刘备哭大哥关羽打二哥张飞骂三弟九、代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容`代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行1234567(```) 代码... 代码... 代码...(```)注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。效果如下：create database hero;代码块1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();十、流程图123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;`效果如下：有些地方可能不支持流程图，所以截了个图：十一、补充实现缩进两种方案手动输入空格 （&amp;nbsp；）。注意！此时的分号为英文分号，但是不推荐使用此方法，太麻烦！使用全角空格(切换快捷键shift+空格)。即：在全角输入状态下直接使用空格键就ok了实现换行两种方案两个回车即可使用&lt; br &gt;字体大小、颜色、类型、加粗、倾斜&lt; font size=5&gt; Hello&lt; font color=red&gt;color&lt; font face=“微软雅黑”&gt;微软雅黑内容 (*与内容之间没有空格)内容 (*与内容之间没有空格)参考来源作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。再推荐一个比较全面的： markdown文档大全","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"},{"name":"markdown","slug":"markdown","permalink":"http://dongdongyan.com/tags/markdown/"}]},{"title":"分类和标签功能测试","slug":"标签和分类测试","date":"2019-04-03T00:38:16.000Z","updated":"2019-04-07T21:52:48.768Z","comments":true,"path":"2019/04/03/标签和分类测试/","link":"","permalink":"http://dongdongyan.com/2019/04/03/标签和分类测试/","excerpt":"","text":"只是用于测试分类和标签功能md文件各属性填写如下：12345title: 分类和标签功能测试date: 2019-04-03 01:38:16categories: 日常随笔tags: [Java,Hexo,git]toc: true # 是否启用内容索引由于本主题的左侧tags 和 categories页面不自动生成，我从主题作者github库中的issues得知两个方法:移动 themes/source/tags和categories文件夹 到根目录的soucre下即可 （但是我自己这边不太好用）12hexo new page “tags” hexo new page “categories”经过亲测， 先移动文件夹再new page一定可以凑效。 其实也可以直接new page 然后修改文件头如上示例。","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://dongdongyan.com/tags/Hexo主题/"}]},{"title":"Blog Theme English document","slug":"README","date":"2019-04-02T19:23:37.000Z","updated":"2019-04-07T21:31:49.213Z","comments":true,"path":"2019/04/02/README/","link":"","permalink":"http://dongdongyan.com/2019/04/02/README/","excerpt":"","text":"pureA brand new default theme for [Hexo]. Preview | 中文说明文档 | iconfontFeaturesMultiple languages supportComment supportTags pageCategories pageSocial MediaSkinsAppearanceHome | Archives | Categories | Tags | Repository | Books | Links | AboutInstall themeExecute the following command under your hexo folder.1git clone https://github.com/cofess/hexo-theme-pure.git themes/pureThen modify the property theme of the file hexo/_config.yml to theme: pureUpdate themeExecute the following command to update theme.12cd themes/puregit pullInstall pluginhexo-wordcount1npm install hexo-wordcount --savehexo-generator-json-content1npm install hexo-generator-json-content --savehexo-generator-feed1npm install hexo-generator-feed --savehexo-generator-sitemap1npm install hexo-generator-sitemap --savehexo-generator-baidu-sitemap1npm install hexo-generator-baidu-sitemap --saveData filesSometimes you may need to use some data in templates which is not directly available in your posts, or you want to reuse the data elsewhere. For such use cases, Hexo 3 introduced the new Data files. This feature loads YAML or JSON files in source/_data folder so you can use them in your site.For example, add links.yml in source/_data folder.links dataadd links.yml in source/_data folder.The format of the link :1234Name: link: http://example.com avatar: http://example.com/avatar.png desc: descriptionAdd a number of links, we just need to repeat the format according to the above.Blog optimizationhexo-neatauto Minify html、js、css and make it neat1npm install hexo-neat --saveYou can configure this plugin in _config.yml.12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &apos;*.min.css&apos;neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos;hexo-baidu-url-submit1npm install hexo-baidu-url-submit --savehexo-translate-titletranslate the chinese title of Hexo blog to english words automatially1npm install hexo-translate-title --saveYou can configure this plugin in _config.yml.123456translate_title: translate_way: google #google | baidu | youdao youdao_api_key: XXX youdao_keyfrom: XXX is_need_proxy: true #true | false proxy_url: http://localhost:8123Mathjax Supporthexo-renderer-markdown-it-plusinstall12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --saveYou can configure this plugin in _config.yml.12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: falseArticle enable mathjax12title: Hello Worldmathjax: true","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://dongdongyan.com/tags/随笔/"},{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"}]},{"title":"博客主题中文文档","slug":"README.cn","date":"2019-04-02T19:23:37.000Z","updated":"2019-04-07T21:31:51.491Z","comments":true,"path":"2019/04/02/README.cn/","link":"","permalink":"http://dongdongyan.com/2019/04/02/README.cn/","excerpt":"","text":"pureA brand new default theme for [Hexo]. Preview | English documentation | iconfont特色多语言第三方评论框（友言、来必力、gitment、gitalk）可展示个人豆瓣书单可展示个人github托管项目可设置支付宝、微信打赏主题颜色页面展示首页 | 归档 | 分类 | 标签 | 项目 | 书单 | 友链 | 关于配置说明在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件安装主题1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure更新主题12cd themes/puregit pull启用pure主题打开站点配置文件，找到theme字段，将其值更改为 pure1theme: pure到此，主题安装完成。然后启动Hexo服务验证主题是否正确启用。1hexo s安装插件hexo-wordcount1npm install hexo-wordcount --savehexo-generator-json-content1npm install hexo-generator-json-content --savehexo-generator-feed1npm install hexo-generator-feed --savehexo-generator-sitemap1npm install hexo-generator-sitemap --savehexo-generator-baidu-sitemap1npm install hexo-generator-baidu-sitemap --save主题配置设置语言打开站点配置文件, 将 language 设置成你所需要的语言。建议明确设置你所需要的语言,可选值对应themes\\pure\\languages目录下语言文件，简体中文配置如下：1language: zh-CN主题颜色定制了五套颜色，默认白，黑:theme-black，蓝:theme-blue，绿:theme-green，紫:theme-purple123# configconfig: skin: # 主题颜色 theme-black theme-blue theme-green theme-purple导航菜单12345678910111213141516171819202122# 导航菜单menu: Home: . Archives: archives # 归档 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories Books: books # 书单 Links: links # 友链 About: about # 关于# 导航菜单图标（font awesome）menu_icons: enable: true # 是否启用菜单图标 home: icon-home-fill archives: icon-archives-fill categories: icon-folder tags: icon-tags repository: icon-project books: icon-book-fill links: icon-friendship about: icon-cup-fill设置个人信息123头像在themes\\pure\\source\\images 目录下替换图片即可，捐献的二维码同理。个人信息大部分都在 主题配置文件 中设置搜索主题内置三种站内搜索方式：insight、swiftype、baidu12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search分享支持weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedin123456# Share# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: true # 是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,qq,qzone # 移动端显示的分享图标评论主题集成了disqus、友言、来必力、gitment、gitalk评论系统，选择其中一种即可12345678910111213141516# Comment# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/comment: type: livere # 启用哪种评论系统 disqus: # enter disqus shortname here youyan: uid: *** # enter youyan uid livere: uid: *** # enter livere uid gitment: githubID: username repo: username.github.io ClientID: *** ClientSecret: *** lazy: false文章浏览量统计主题内置了不蒜子和leancloud来统计文章浏览量，启用其中之一即可，注意leancloud需要到其官网申请APP ID 和APP Key。比如，启用不蒜子来统计文章浏览量，在主题配置文件中把busuanzi设置为true即可：123pv: busuanzi: enable: true # 不蒜子统计如果不需要第三方来统计浏览量，只需将相应设置改为false即可（设置为false后不会加载第三方JS脚本）Github respostory复制theme/pure/_source/ 目录下repository文件夹到blog path/source/ 目录下123# Githubgithub: username: *** # github username豆瓣书单复制theme/pure/_source/ 目录下books文件夹到blog path/source/ 目录下12345# douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数友情链接复制theme/pure/_source/ 目录下links文件夹到blog path/source/ 目录下在 hexo 目录下的 source 文件夹内创建一个名为 _data（禁止改名）的文件夹。然后在文件内创建一个名为 links.yml 的文件,在其中添加相关数据即可。单个友情链接的格式为：1234Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot;添加多个友情链接，我们只需要根据上面的格式重复填写即可。. 将 Name 改为友情链接的名字，例如 Cofess。. http://example.com 为友情链接的地址。. http://example.com/avatar.png 为友情链接的头像。. 这是一个描述 为友情链接描述。文章索引目录123456title: 文章标题categories: - 文章分类tags: - 文章标签toc: true # 是否启用内容索引sidebar侧边栏文章侧边栏默认为开启状态，如果某篇文章不想开启侧边栏，在文章开头配置加入“sidebar: none”即可：123456title: 文章标题categories: - 文章分类tags: - 文章标签sidebar: none # 是否启用sidebar侧边栏，none：不启用博客优化hexo-neatauto Minify html、js、css and make it neat1npm install hexo-neat --save在博客配置文件_config.yml中添加12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &apos;*.min.css&apos;neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos;hexo-baidu-url-submit1npm install hexo-baidu-url-submit --savehexo-translate-title使用Google翻译，百度翻译和有道翻译将Hexo中的汉字标题转成英文标题安装1npm install hexo-translate-title --save在博客配置文件_config.yml中添加123456translate_title: translate_way: google #google | baidu | youdao youdao_api_key: XXX youdao_keyfrom: XXX is_need_proxy: true #true | false proxy_url: http://localhost:8123注意：判断是否需要配置google本地代理，因为我在本地是开启时才能访问google翻译的，如果没有被墙，请将_config.yml 下的is_need_proxy: true改为false。如果设置为true,请设置本地代理地址数学公式Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签解决方案解决方案有很多，可以网上搜下，为了节省大家的时间，这里只提供亲身测试过的方法。更换Hexo的markdown渲染引擎，hexo-renderer-markdown-it-plus引擎替换默认的渲染引擎hexo-renderer-marked即可。安装hexo-renderer-markdown-it-plus插件12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save配置安装插件后，如果未正常渲染LaTeX数学公式，在博客配置文件_config.yml中添加12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false文章启用mathjax12title: Hello Worldmathjax: true","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://dongdongyan.com/tags/随笔/"},{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"}]},{"title":"Speed Test(书写格式模板)","slug":"Test","date":"2019-03-26T20:23:37.000Z","updated":"2019-04-20T14:31:48.245Z","comments":true,"path":"2019/03/26/Test/","link":"","permalink":"http://dongdongyan.com/2019/03/26/Test/","excerpt":"","text":"第一章 上二级标题测试再来一个二级标题第二章 中第三章 下- 第一章 上只是测试一下如果用Github托管，在国内浏览此博客的速度你说呢br要加在上一行的后边我也不知道啊你呢我不知道1一个代码看看行不我觉得你这个代码不是很好1你再看看这个代码怎么样！到底知道不知道1试试就知道那你知道吗？- 再来一个二级标题第二章 中第三章 下","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://dongdongyan.com/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-26T20:20:00.404Z","updated":"2019-04-19T20:38:47.168Z","comments":true,"path":"2019/03/26/hello-world/","link":"","permalink":"http://dongdongyan.com/2019/03/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]},{"title":"电脑使用中的小知识积累","slug":"电脑使用中的小知识积累","date":"2019-02-16T16:20:31.000Z","updated":"2019-06-24T16:21:09.328Z","comments":true,"path":"2019/02/16/电脑使用中的小知识积累/","link":"","permalink":"http://dongdongyan.com/2019/02/16/电脑使用中的小知识积累/","excerpt":"","text":"bin 文件夹bin 是binary的缩写，一般用来放可执行文件，或者编译后可运行的二进制文件。 常包含 .exe或.dll格式的文件。","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://dongdongyan.com/categories/计算机基础知识/"}],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://dongdongyan.com/tags/计算机基础知识/"}]}]}