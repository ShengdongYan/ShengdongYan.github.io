{"pages":[{"title":"分类","date":"2019-04-07T17:46:04.823Z","updated":"2019-04-07T17:46:04.823Z","comments":false,"path":"categories/index.html","permalink":"http://dongdongyan.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-07T18:35:53.547Z","updated":"2019-04-07T18:35:53.547Z","comments":false,"path":"about/index.html","permalink":"http://dongdongyan.com/about/index.html","excerpt":"","text":"关于我："},{"title":"友情链接","date":"2019-04-07T17:46:50.558Z","updated":"2019-04-07T17:46:50.558Z","comments":true,"path":"links/index.html","permalink":"http://dongdongyan.com/links/index.html","excerpt":"","text":""},{"title":"项目仓库","date":"2019-04-07T17:40:25.454Z","updated":"2019-04-07T17:40:25.454Z","comments":false,"path":"repository/index.html","permalink":"http://dongdongyan.com/repository/index.html","excerpt":"","text":""},{"title":"我的相册","date":"2019-04-07T18:12:21.470Z","updated":"2019-04-07T18:12:21.470Z","comments":true,"path":"photo/index.html","permalink":"http://dongdongyan.com/photo/index.html","excerpt":"","text":"待开发。。。。。。"},{"title":"标签","date":"2019-04-07T17:45:34.065Z","updated":"2019-04-07T17:45:34.065Z","comments":false,"path":"tags/index.html","permalink":"http://dongdongyan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java1.8 Lambda表达式+Function+Stream","slug":"Java1.8 Lambda表达式+Function+Stream","date":"2019-05-15T21:41:02.000Z","updated":"2019-05-06T17:44:09.347Z","comments":true,"path":"2019/05/15/Java1.8 Lambda表达式+Function+Stream/","link":"","permalink":"http://dongdongyan.com/2019/05/15/Java1.8 Lambda表达式+Function+Stream/","excerpt":"","text":"自Java 8 (JDK1.8) ，推出了几个新的重要特性，这篇博文主要介绍了 Lambda，Function,Stream这三个新特性的概念，意义，实际应用等。1. Lambda表达式：只有函数性interface接口才能用:Interface里只能有一个抽象方法。 如果要加其他方法，加 default void test(); 或者其他方法来自于Object 如toString(); (其实是为了在调用时为了让系统知道哪个方法被调用了) 。 在调用实现这个接口的类来运行该方法时，可以直接把方法当做一个参数去操作，省去实现类，提升了代码的整体性，简洁性等。12345678910111213141516171819202122232425262728293031323334Runnable a = new RunnableThread(&quot;一个实现了runnable接口的类&quot;);new Thread(a).start(); //这是一种常规的线程声明和运行办法// 匿名类的实现方法如下： new Thread(new Runnable() &#123; @Override public void run() &#123; Thread.sleep(1000); &#125; &#125;).start();//下面是Lambda表达式的方法,只要一行解决。// 1. statement方式，只有一句要执行的内容， 如果是有返回值的方法，不用写return， 自动识别 new Thread(()-&gt;System.out.println(&quot;Lambda&quot;) ).start(); //2. 语句块的模式，多句语句用&#123;&#125;包裹，如果有返回类型， 要写return；MyInterface interface = (String S, String SS) -&gt; &#123; System.out.println(&quot;接口省去写实现类&quot;); System.out.println(&quot;接口中的唯一方法名为test&quot;); System.out.println(&quot;接口中的方法具体这样实现重写&quot;); System.out.println(&quot;在1.8之前通常用匿名类的方式写&quot;); System.out.println(&quot;下面是这个方法的返回值&quot;); System.out.println(&quot;然后是调用&quot;); return SS；&#125;sout(interface.test()); // 或sout(interface::test);//3. 还有一种就是方法引用 ,用：：代替函数的调用 比如 Student.getName(); 等于Student::getName; 作为最为输入参数传入接口的方法，类型要一致, 相当于Lambda表达式的简写模式。MyInterface interface = String::new; (test 方法需要一个String,作为输入参数）；interface.test(“nihao”);2. Function接口： 把逻辑和业务分开，单独在需要用的时候写明需要具体执行的业务，更加灵活；Function&lt;T,R&gt; T是输入类型，R是要返回的类型！！！！！！！！！！！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546//下面是一般应用public Static Integer testFunction(Function&lt;Integer, String&gt; fun, String S)&#123; return fun.apply(S); &#125;// 调用时 testFunction(S-&gt;String.valueOf(S), &quot;123&quot;);-------------------------------------------------------------------------// 下面是经常用于处理Collection容器的完整例子public class LambdaTest &#123; List&lt;Apple&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;Apple&gt; filtApple(Predicate&lt;Apple&gt; predict)&#123; ArrayList&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: result)&#123; if(predict.test(apple))&#123; result.add(apple); &#125; &#125; return result; &#125; class Apple&#123; String name; int id; String Color; &#125; public static void main(String[] args) &#123; LambdaTest test = new LambdaTest(); test.filtApple(a-&gt;a.name.equals(&quot;ChineseApple&quot;)); test.filtApple(a-&gt;a.Color.equals(&quot;red&quot;)); // 这样就不用对每一种筛选条件都写一个接口了 &#125;&#125;Stream: 对集合进行遍历等操作，性能得到优化自己不储存对象不改变源对象，只返回一个新的Stream延迟执行，等到结果才执行,整个Stream其实只遍历了一次ArrayListlist = new ArrayList&lt;&gt;();list.stream.forEach(System.out::println);list.stream.forEach(a-&gt;System.out.println(a.getColor());Comparatorcomparator = Comparator.comparing(Apple::getName).thenComparing(Apple::getName).reversed();应用总结：12345678910111213141516171819202122232425262728293031323334//排序//第一阶段匿名类 ArrayList&lt;Apple&gt; list = new ArrayList&lt;&gt;();Collections.sort(list, new Comparator&lt;Apple&gt;()&#123; @override public int compare(Apple a1, Apple a2)&#123; return a1.getID()-a2.getID(); &#125;&#125;);////第二阶段 lambadaCollections.sort(list, (a1, a2)-&gt; a1.getID()-a2.getID());//第三阶段 StreamArrayList&lt;Apple&gt; newlist = list.stream.sorted((a1, a2)-&gt; a1.getID()-a2.getID()) .collection(Collectiors.toList());//过滤//过滤一个容器，上边2。中关于Function的代码是第二阶段//第三阶段Stream Map&lt;String S, List&lt;Apple&gt;&gt; groupedMap = list.stream.filter(a-&gt;a.name.equals(&quot;ChineseApple&quot;)) .filter(a-&gt;a.Color.equals(&quot;red&quot;)) .sorted((a1, a2)-&gt; a1.getID()-a2.getID()) .reversed(); .forEach(System.out::println); .collection(Collectiors.groupingBy(Color); //按照颜色分类返回一个map","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Lambda表达式，JDK1.8，Function,Stream","slug":"Lambda表达式，JDK1-8，Function-Stream","permalink":"http://dongdongyan.com/tags/Lambda表达式，JDK1-8，Function-Stream/"}]},{"title":"LeetCode刷题笔记","slug":"LeetCode刷题笔记","date":"2019-05-02T22:34:50.000Z","updated":"2019-05-06T22:16:10.544Z","comments":true,"path":"2019/05/02/LeetCode刷题笔记/","link":"","permalink":"http://dongdongyan.com/2019/05/02/LeetCode刷题笔记/","excerpt":"","text":"简介：Hash:Array：List:String：Stack；Tree:Queue:Graph:简介：在这里主要整理一下LeetCode的刷题笔记和数据结构总结，我计划先按照AC率刷50道练手热身，再按照标签刷；目前先按照类型整理, 格式： 类型 + 题号+ 笔记； 下一个题号+ 笔记；Hash:插入，查询，删除的效率都是O（1）； Java中的 loadfactor=0.75 = n/T; 所以复杂度是常数771 : 在各种数据结构中 hash的搜索查询速度是最快的 O（1）。具体来说: 是因为，在查询一个key时，会直接用对应的方法计算出对应的 hashcode和table里的位置，而table的底层是数组加链表，（1.8后当链表长度超过8，自动转化为红黑树）， 对于给定位置的查询Array无疑是最快的，所以hash用作查询最快.(hashset用于存单个的不重复的值，hashmap的value设成了null,hashtable比较慢。因为方法都加了sychronized保证安全);但是，这道题String的foreach更快，可能是因为查询的东西比较短，转化到hash的时间不太值。804 二十六个字母 从 a-z可以用加法 比如 char b = ‘a’++; b就是‘b’ ; 另外利用好Set可以自动剔除重复元素，就不用自己一个个判断了Array：807 ： 学会找二维数组纵向最大值投影和横向最大值投影（从上往下看，生成列的最大值数组，从左往右看生成行的最大值数组），也相当于学会了找行的最大值和列的最大值1234567891011int [][] d = &#123;&#123; 2, 3, 4&#125;,&#123; 5, 6, 7&#125;,&#123;24,25,26&#125;,&#123; 6, 7, 8&#125;&#125;;for (int[] element : d)&#123;for (int el : element)&#123;System.out.printf(&quot;%4d &quot;,el);&#125;System.out.println();&#125; // 遍历二维数组的方法654: 数组需要单次找最大最小时可以用下面的方法，但是如果不断的得到subarray或者递归时，最好还是自己手动写一个 int left 和 int right来记位置，当参数，每次递归就更新。三种找到数组中最大值的方法： 1. Arrays.sort(arr); 2. (int)Collection.max(Arrays.asList(arr); 3. Arrays.stream(arr).max().getAsInt();List:String：对于经常改变的String,用StringBuilder更节省空间。 .toString(); new StringBuilder(String S); .append(String S);Stack；Tree: 学会合理用递归938 给出一个范围，找到该范围内BST所有node的和。 用recursion654 对于空输入想输出异常时，用IllegalArgumentException 或IllegalStateExceptionthrow new IllegalArgumentException(“deleteHB: value is not in the tree”);Queue:Graph:##","categories":[],"tags":[]},{"title":"Java基础知识（持续更新）","slug":"Java基础知识（持续更新）","date":"2019-04-16T15:20:31.000Z","updated":"2019-05-06T23:16:42.204Z","comments":true,"path":"2019/04/16/Java基础知识（持续更新）/","link":"","permalink":"http://dongdongyan.com/2019/04/16/Java基础知识（持续更新）/","excerpt":"","text":"最近在读Java圣经-Java编程思想/Thingking in Java 第四版， 正好以笔记的形式整理一份Java的基础知识。Java-OOP编程的基础思想万物皆对象，我们应该想办法构造对象，然后对于这些对象以单位进行操作。（当然，对象都来自于不同的类，或者说类型）。每个对象应该尽可能的简单，只针对特定的功能，或者只针对特定的一个问题而创造，而不是想把所有问题都用一个类来解决。（对于更多的设计模式或者编程思路，我后期会再单独开一篇,这里就不多阐述了）关键字 访问权限（access specifier） public,private,protected,defaultpublic：具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于 对外 的情况，也就是对象或类对外的一种接口的形式。protected：主要的作用就是用来保护 子类 的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西default：有时候也称为friendly，它是针对 本包访问 而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。private：访问权限仅限于类的 内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。所有private的东西不会被继承。关键字 方法的继承模式- overload, override, overwrite.区分方法是否相同(/是否重载)与访问权限和返回类型无关, 只看名字+输入参数（包括参数数量，顺序，类型 ：1234567public void add()&#123;&#125; private void add()&#123;&#125; //是同一个方法,不允许同时出现。---------------------------------------------public int add(int a , int b)&#123;&#125;public double add(int a, int b)&#123;&#125; // 不允许，名同和参数同。overlaod（重载）: 是一个全新的方法，只是于原方法的名字相同，输入参数的类型或者数量或者参数的顺序或返回类型都可能不同。于多态无关override覆盖（重写，复写）: 覆盖父类或者接口中的方法，方法名同，参数同，返回类型同，只有内容不同。 贡献了多态性overwrite: java里没有，相当于override.补充：封装、抽象、继承和多态。封装：在面向对象语言中，封装特性是由类来体现的，我们将现实生活中的一类实体定义成类，其中包括属性和行为（在Java中就是方法），就好像人类，可以具有name,sex,age等属性，同时也具有eat(),sleep()等行为，我们在行为中实现一定的功能，也可操作属性，这是面向对象的封装特性；抽象：抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。比如鸟就是一个抽象实体，因为抽象实体并不是一个真正的对象，它的属性还不能完全描述一个对象，所以在语言中体现为抽象类不能实例化；继承：继承就像是我们现实生活中的父子关系，儿子可以遗传父亲的一些特性，在面向对象语言中，就是一个类可以继承另一个类的一些特性，从而可以代码重用，其实继承体现的是is-a关系，父类同子类在本质上还是一类实体；多态：多态就是通过传递给父类对象引用不同的子类对象从而表现出不同的行为 …类和类的关系- is-a, is-like-a,has-a;is-a: 继承关系，子类的全部接口（方法）在父类里也有is-like-a: 继承关系，子类里新增了一些接口has-a: 一个类的对象成了另一个类的属性向上转型（upcast）和向下转型转型(downcast)：详细内容参考：Java向上转型和向下转型把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。如Father father = new Son();把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型,要向下转型，必须先向上转型为了安全可以用instanceof判断。如father就是一个指向子类对象的父类引用，把father赋给子类引用son 即Son son =（Son）father；其中father前面的（Son）必须添加，进行强制转换。upcasting 会丢失子类特有的方法(只能调用父类中存在的方法和属性),但是子类overriding 父类的方法，子类方法有效（同名不同内容的变量也一样道理），向上转型只能引用父类对象的属性，要引用子类对象的同名属性，则要写getter函数 ,不可以.属性如：1234567891011// 父类有一个方法 public void add(Father f)&#123; System.out.println(f.name);&#125; //这样只会返回Father类里的name,就算后来输入的是son. 所以应该如下：public String getName()&#123; return this.name;&#125;public void add(Father f)&#123; System.out.println(f.getName());&#125;向上转型的作用，当用大家都有的方法时，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。（坏处就是如果向上转型后，如果还想调用子类独有的方法，还要向下强制转型，所以其实向下转型是一种向上转型的附属品）如：12345678public void add(Father f)&#123;&#125;//在调用时可以add(new Son());//或者Son s = new Son(); add(s); //节省了代码量,因为当有很多子类时，不用对所有的子类类型都写一个add（Son1 s），add(Son2 s)方法单根集成结构：所有OOP语言（除了C++外），所有的类都最终集成自单一的基类，（Java是都来自Object类）； 好处： 1.垃圾回收很容易（相比于C++的重要改进） 2. 方便确定变量类型，进而处理异常。7. Java 数据类型：Java中的变量分为基本类型和引用类型两种。基本类型的变量保存数值本身，而引用类型的变量保存的是引用值，即指向内存空间的地址。 八大基本类型包括：byte,char,int short,long,float,double,boolean; (大写的 String, Integer, Double等是其对应的包装类) 引用类型包括：类类型，接口类型和数组。 在声明基本数据类型时，计算机就分配了内存空间： *基本类型在声明其变量时就为它分配了空间，而且 变量名字直接代表内存地址*： 1231 int value; 2 3 value = 10;//正确，因为声明a时就分配了空间*而引用不同，在进行引用的声明时只给变量声明了引用空间，而不分配数据空间，类名只是一种引用，引用了真正存内容的首位地址（由此牵扯出判断两个对象的内容是否相等的方法在第17中会提及）：123456789101112 Date date; //执行实例化，开辟数据空间存放Date对象，然后把空间的首地址传给today变量 date=new Date(); //如果注释掉上一步操作 //The local variable date may not have been initialized //也就是说对象的数据空间没有分配 date.getDate();//初始化过程如下：Date a,b; //在内存开辟两个引用空间, 现在不能a = new Date();//开辟存储Date对象的数据空间，并把该空间的首地址赋给a b = a; //将a存储空间中的地址写到b的存储空间中所以写代码的时候有一种简化代码的思路是，省去引用，直接利用对应的对象或者结果，而不是先new 再利用,尤其是当这个引用只下下面紧接着的一部分被利用如：123456 this.add（new Integer(22); // 等于this.add(22); 而不是 int a = 22; this.add(a);boolean test(int i1, int i2 )&#123; return i1==i2;&#125;补充： 形参： 传入方法或者类的参数 如: void add(int a){}// int a 是形参 实参：实际操作针对的参数，如 int a = 10; add(a); // a 为实参 1）形参为基本类型时，对形参的处理不会影响实参。 void add(int a){ a++;// 不会影响外部的a 值。 } 2）*形参为引用类型时，对形参的处理会影响实参。* Date a = new Date(); void add(Date a){ a.setTime(123);// 会影响外部的a。 } 3）String,Integer,Double等immutable类型的特殊处理，可以理解为值传递，形参操作不会影响实参对象。 看一个有趣的例子： 另外，假如Tank里有一个变量 int a =10; 如果改变了Tank.a他所有的子类里的a的值都会变化。 泛型 GenericType（参数化类型）出现自JavaSE5 以后：详细内容：Java泛型典型例子ArryListlist = new ArrayList();String 就是参数化类型的应用所在。 在Java5之前，我们在这种集合类中都是默认存入的是Object类,存入时我们要向上转型到Object类，取出时我们还需要人为记住每一个位置的类型并强制向下转型，很麻烦（其实现在内部也是存入的Object，只是我们看不到）。好处：1 可读性，从字面上就可以判断集合中的内容类型；2 类型检查，避免插入非法类型。3 获取数据时不在需要强制类型转换。(补充： 遇到’E’,’T’,’A’,,&lt;K,V&gt;等，是用到了java中的泛型。 一般使用来声明类型持有者名称，自定义泛型类时，类持有者名称可以使用T(Type) 如果是容器的元素可以使用E(Element)，若键值匹配可以用K(Key)和V(Value)等， 若是&lt;?&gt;，则是默认是允许Object及其下的子类，也就是java的所有对象了。所以说，如果是字母A,B,C,D…定义的，就是泛型，这里T只是名字上的意义而已,你也可以用A，B等等： T—type,E—-Element K—-key, V—-value 如果是？定义的，就是普通的Object或者其子类 举例说明： Set表示 集合里 是 T类的实例 List表示 集合里是E类的实例 List&lt;?&gt; 表示 集合里的对象类型不确定，未指定List同 List&lt;?&gt; 是一样的。)通配符 wildcard:类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box、Box…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。123456789101112131415161718 1 public class GenericTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Box&lt;String&gt; name = new Box&lt;String&gt;(&quot;corn&quot;); 6 Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); 7 Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); 8 9 getData(name);10 getData(age);11 getData(number);12 &#125;13 14 public static void getData(Box&lt;?&gt; data) &#123;15 System.out.println(&quot;data :&quot; + data.getData());16 &#125;17 18 &#125;有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。1234567891011121314151617181920212223242526 1 public class GenericTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Box&lt;String&gt; name = new Box&lt;String&gt;(&quot;corn&quot;); 6 Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); 7 Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); 8 9 getData(name);10 getData(age);11 getData(number);12 13 //getUpperNumberData(name); // 114 getUpperNumberData(age); // 215 getUpperNumberData(number); // 316 &#125;17 18 public static void getData(Box&lt;?&gt; data) &#123;19 System.out.println(&quot;data :&quot; + data.getData());20 &#125;21 22 public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123;23 System.out.println(&quot;data :&quot; + data.getData());24 &#125;25 26 &#125; 此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。 类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。 总结:限定通配符总是包括自己上界类型通配符：add方法受限(因为无法确定具体存入类型)下界类型通配符：get方法受限（不强转）如果你想从一个数据类型里获取数据，使用 ? extends 通配符如果你想把对象写入一个数据结构里，使用 ? super 通配符如果你既想存，又想取，那就别用通配符不能同时声明泛型通配符上界和下界详细解释：储存区（包括堆栈）+基本类型详细介绍：来自于 Java编程思想第四版22页，我的github库里有一个专门的电子书籍整理，可自行下载。补充； Sting 类型的大小是每位字符都用2字节（16bits）来表示；BigInteger可以支持任何大小的整数，BigDecimal可以支持任何精度的小数。当基础数据类型作为类的数据成员时（global variable时），会有一个默认值,如下:1、整数类型（byte、short、int）的基本类型变量的默认值为0。2、单精度浮点型（float）的基本类型变量的默认值为0.0f。3、双精度浮点型（double）的基本类型变量的默认值为0.0d。4、字符型（char）的基本类型变量的默认为 “/u0000”。（null）5、布尔性的基本类型变量的默认值为 false。6、引用类型的变量是默认值为 null。7、long - 0l;8、数组引用类型的变量的默认值为 null。除关键数组变量的实例后，如果没有没有显示的为每个元素赋值，Java 就会把该数组的所有元素初始化为其相应类型的默认值。在作为local variable时必须手动初始化赋值9 基本数据类型间的转换关系: 向上转换可以直接隐式，向下转换必须强转（int）数据可能会丢失，包括大小范围，和精度12. 关键字 static:&gt;[Java static](https://www.cnblogs.com/dolphin0520/p/3799052.html) 1. static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化，所有新的对象会共享，（一个地方改变，其他地方也会变）。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进行初始化。static 不可以用来修饰局部变量（规定）。 2. “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 3. 所以在使用时，如果对于整个类都比较通用的变量或者方法，即静态的东西，就可以加上static. java.lang类包是默认导入每个文件里的，所以我们用的基础类型都不用额外import了。14. 代码执行顺序、初始化顺序：1.找main()方法， 加载 main所在类的static变量以及方法 2. 加载并初始化该类的其他变量，再执行main方法， 3. 如果main里new了一个类，先加载该类的父类（的static 变量和方法），然后加载自己的static变量和方法，接着为了执行他的构造器，发现有个父类4.初始化父类里的普通变量（没有指定地址的为null或者0），运行加载父类的构造器,给对应的变量赋值，5.最后才初始化自己的变量， 最后执行new 新建对象,给自己对应的变量赋值。简单来说就是当发现一个新的类时会直接先加载这个类的static的东西，当有方法要执行之前会加载该方法所在类的其他普通量。 （static 修饰的东西只会初始化一次，就是该类首次生成一个对象时）配合例子：static 面试题在类的构造器中尽可能只做赋值，而不调用方法，尤其是作为父类时， 否则子类运行构造函数之前就会再父类中运行在子类中重写的函数，但是子类中的有些变量可能还没有初始化，所以运行结果会是错误的。15. 编码风格（命名风格）- 驼峰风格：详见 ：Java命名规范+注释规范包名，项目名: 全小写；类名：每一个单词的首字母都大写其他部分小写：class AllTheColorsOfTheRaindow{//…}常量（static final的不怎么变化的量）： 全大写多个单词用_隔开；其他变量，包括方法名： 第一个单词首字母小写，其他的也是首字母大写void allTheColorsOfTheRaindow(){//….}16. 算数操作符：12345678910111213141516171819% 取模（结果代表余数） 3%6 =3;%= 取整数部分 3%=6 =0; int a = 5;a = a++;System.out.println(a); //5//或者 int a = 5; int b = 3 + a++; // b = 8 , a = 6;-------int a = 5;a = ++a;System.out.println(a);//6//或者 ，int a =5; int b = 3+ ++a; b = 9, a =6;17. 关系操作符： == 比较的是地址，不是内容（对于基本操作类型可以直接==比较）因为就像前面说的，Integer i = new Integer(3); // 这里的 i 只是引用了具体对象的首位地址， 所以 i1 == i2； 是相当于比较了两个对象的首位地址。比较内容用 equal方法，如果没有可以自己在类中override 写一个出来,如果没有重写，equal 方法默认比较的是地址，还是会返回false。注意： Integer i1 = new Integer(3);\\ Integer i2 = i1; System.out.println(i2==i1); //true 两个东西是相同的引用，指向同一个地址 重写equal方法的例子：123456789101112131415161718@overridepublic boolean equals(Object obj) &#123; //由于是重写，参数只能是Object oif (this == obj)return true;if (obj == null)return false;if (getClass() != obj.getClass())return false;Person other = (Person) obj;if (age != other.age)return false;if (name == null) &#123;if (other.name != null)return false;&#125; else if (!name.equals(other.name))return false;return true;&#125;补充：用equal和hashcode方法判断两个对象的内容是否相等总结： ==是判断引用地址； 重写 .equal（）方法是判断相对相等；hashcode一般是在重写.equal（）方法的同时也重写 一个 public int hashCode(){},如果不重写，每个对象的hashcode生成和该对象的存储地址，以及字段都有关系，一般用于往hashmap,hashset,hashtable添加对象的时候使用，如果hashcode相同了，再看equal是否为true,如果为true就代表两个元素相同，更新value值。这个方法是用来提高往哈希集中添加元素的效率，不用每次都调用equal去比较。因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是 不可以的，因为不同的对象可能会生成相同的hashcode值（比如a= 3+3, b =2+2+2）。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode 值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；如果两个对象的hashcode值相等，则equals方法得到的结果未知。18. 短路：boolean result = a&amp;&amp;b&amp;&amp;c; System.our.println(result);// a,b ,c 是三个 boolean值或者可以改成三个返回boolean的方法，只有a是true才会接着看b, 然后只有b是true,才会接着看c。 19. 三元操作符：简单的if-else逻辑时很好用,简洁：static int test(int a){ return a&gt;10 ? a/10 ： a*10; } 20. 字符串操作 +1234int x = 0 , y = 1, z= 2;String s = &quot;x,y,z&quot;; System.out.println(s+x+y+z); //结果是想x,y,z012, 以字符串开头的表达式，后续会自动转换成字符串，也必须是字符串。所以 “”+x 相当于 Integer.toString(x);System.out.println(s+(x+y+z));// 结果是x,y,z321.类型转换:小类型可以自动转化成大类型，但是大类型只能强制转化成小类型（因为信息会丢失）， 如 flaot f 和double d 转化成一个 int i =(int) f;这里都不会四舍五入，只会只保留整数部分， 同样的char, byte, short 在有需要的情况下会自动转化成 int. 一般一个运算最后的结果类型是以最大的类型为结果。八种基本类型站bit位如下：boolean: 1;byte: 8;char: 16;short: 16;int: 32;flaot: 32;double:64;long:64;22.常见的占位符：Java占位符大全12345678910int year=2017;int month=6;int day=1;&lt;/P&gt;String str=String.format(&quot;今天是%d年%d月%d日，祝大家儿童节快乐！！！&quot;, year, month, day);//这样以来就不用一直用+号连接各部分了//如果直接用于打印： System.out.printf(&quot;今天是%d年%d月%d日，祝大家儿童节快乐！！！&quot;, year, month, day);23.Java string和各种格式互转:简单收集记录下:其他类型转String与基本类型和包装类String s = String.valueOf( value); // 其中 value 为任意一种数字类型。字符串型转换成各种数字类型：String s = “169”;byte b = Byte.parseByte( s );short t = Short.parseShort( s );int i = Integer.parseInt( s );long l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );(或者都可以调用toString 方法)。与字节数组 byte[]字节数组—&gt;String : 直接String 的构造器String—&gt;字节数组： String.Bytes();与字符数组 char[]字符数组—&gt;String : 直接String的构造器String—&gt;字符数组： String.tocharArray();StringBuilder:StringBuilder s = new StringBuilder(String s);String S = s.toString();24. 递归的核心思想，从最简单最基础的情形做起，再让复杂的情形逐步的退回到最简单的情形再进行操作，详细例子看练习题。25. return, break,continue:return; : 直接结束一个方法。 void 方法里用 return; 就是这个用途； break; : 结束或者说跳出循环 continue;: 不再继续执行当前的循环，直接进入下一圈循环。 26. 可变参数列表：等于对应的array，只不过稍微更灵活一点： void test(Integer...args){ for(Integer i:args){ System.out.println(i); } } 在调用时： this.test(1,2,3,new Integer(4)); 、、这种就更灵活一点 27. 枚举类 enum: 在创建时，自动为他添加 to.String(); ordinal() ; .values()方法。 枚举类和switch语句配合非常好用。28. 一个 .java 文件（是一个编译单元）最多只有一个public类 ， 其他的类可以用 内部类的形式声明：public class A(){///} class b(){} class c(){}// 当你至于要一两个简单的类来支持类a的使用时，这样非常高效。 如果不想外部访问一个类，可以不写public， 但不能写成 private或者protected； 另一个方法是把类的构造器写成private。 29. 复用类的三种方式：1.组合（一个类的对象在另一个类中当成变量使用）2.继承3.代理： 一个类的对象a 在另一个B中作为变量声明（一般写成private），然后用类B的方法接口来传递输入到a,这样就既可以让用户有选择的使用a,又可以不用像继承一样把a的所有内容都暴露出来。30. 关键字 final(不变的,不能让该引用指向新的地址，或者说不能改变他的值，但是final 对象可以改变对象中的值，虽然不可以让该引用指向其他地址) (static可以理解为，静态的，事先加载的,不面向对象的，针对类):既是final 又是static 时，就只占据固定的内存，减少了计算负担，声明常量时非常好用。 全大写，字母与字母下划线隔开。 final修饰的方法，目的在于不让子类重写该方法。private 方法被归于final,也不能重写。 final类表示该类不可以被继承。 31. Java 中除了final 和static方法外，所有方法都是动态绑定，也就是说只有在运行的的时候才知道具体调用这个方法的对象。 Java中所有的方法都是通过这种动态绑定实现了多态。32. 关键字 abstract:抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象类。抽象方法格式： abstract void add();抽象类里，无法被实例化，可以不包含抽象方法。但是，只要包含抽象方法的类必须被声明为抽象类。33. 接口 关键字 interface： 一个完全抽象的类（public interface Bird{//…}），只包含抽象方法 但是不需要用abstract关键字了： public void add();接口中，只能用 public修饰符，可以不写出，但是也会被默认为public,（变量都是 public static final的常量）接口可以被多实现，既 implements Interface1, Interface2{//…} 这就是为什么我们通常implements Runnable 而不是 extends Thread 来创建新的线程类了，如果你用了继承，就无法再继承别的了，但是接口可以多个。而且，一个接口类可以extends 多个其他接口类，只需要写出自己新的方法，实现的类需要实现以上所有接口的方法。实现接口的类里必须重写所有的接口中的方法实现接口的类可以向上转型成接口的类。当为了 1. 不让使用者创建新的对象（与抽象类同）2. 能够多实现接口时，应使用接口3. 如果确定一种类为基类时，最好是写成接口。补充： 接口经常被应用于‘策略设计模式’：1234567891011121314151617181920212223242526272829303132public interface Processor&#123; public String process(String s);&#125;public class Upper implements Processor&#123; public String process(String s)&#123; return s.toUpperCase(); &#125;&#125; public class Lower implements Processor&#123; public String process(String s)&#123; return s.toLowerCase(); &#125;&#125;//下面是应用， public class Test&#123; public static String applyPro(Processor p, String s)&#123; return p.process(s); &#125; public static void main(String[] args)&#123; print（applyPro(new Upper(), &quot;Dongdong&quot;)）； print(applyPro(new Lower(), &quot;Dongdong&quot; )); &#125; &#125; // 这样以来，在不同的applyPro 方法里就可以填入 Upper class或者 Lower class的对象，这样以来，就可以只用一个方法就灵活的策略一个String。34. 内部类，包括成员内部类，局部内部类，匿名（内部）类: 方便访问外部类的私有变量(能访问外部类的所有成员，当成自己的用)；12345678public class Test&#123; public String s = &quot;nihao&quot;; (public/private) class InnerTest&#123; //成员内部类,在方法里的交局部内部类 public void test()&#123; print(s); &#125; &#125;&#125;35. Java Collection框架，包括List,set,map等知识的总结单独开了一篇，后边整理数据结构可能会直接写进去： Java容器基础知识。36. 异常处理：好处，可以把异常机制和业务机制分离，不用让开发人员人为的把所有可能出错的地方都考虑进去。当Java程序出现以上的异常时，就会在所处的方法中产生一个异常对象。这个异常对象包括异常的类型，异常出现时程序的运行状态以及对该异常的详细描述。作为程序员，我们只需要手动写明可能出现的checked exception:,对于runtime exception我们只需要用if-else去避免try,catch,finally执行顺序：try - catch 2. 给对应的返回值赋值（但是还没有返回），一般finally里不要写返回值 3. 执行finally ，然后返回值，结束方法。37. String:String的对象是不可变的(每次一个新的值都储存在了常量池中)，每次修改其实是新建了一个对象（但是 StringBuilder类可以直接调用 append(), 所以当你需要对一个字符串多次叠加改变，用StringBuilder可以节省内存，如果编写toString方法，操作比较简单，用String好）常用方法：length();charAt();toCharArray();//把所有字符生成到一个数组里compareTo(); //按词典顺序比较indexOf();substring();concat(); // = + String 相加replace(1 ,2);//toLowerCase()// toUpperCase();trim(); // 去除两端的空白部分valueOf(); //其他类型转换成String;格式化说明符Formartter（用来修饰或者规范输出的格式，比如打印固定长度的字符串，或者控制小数点位数，日期，日历，打印出一个表格的形式等等，,同占位符组合使用）：格式:%[argument_index$][flags][width][.precision]conversion2 格式说明（1）argument_index$：指定对应的内容参数位置，默认按照顺序依次对应。（2）flags：格式控制。（3）width：区域宽度。（4）.precision：对于浮点型数据，表示显示的小数位数；对于字符串数据，表示显示的字符数量。（5）conversion：类型转换字符。当只需要规范一次，直接用String.format更方便。4.正则表达式：用于格式的匹配，比如看看输入的是否是一个邮箱的标准格式等等。常用：x 字符 x。举例：&apos;a&apos;表示字符a \\\\ 反斜线字符。 \\n 新行（换行）符 (&apos;\\u000A&apos;) \\r 回车符 (&apos;\\u000D&apos;) 字符类[abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） [0-9] 0到9的字符都包括 预定义字符类. 任何字符。我的就是.字符本身，怎么表示呢? \\. \\d 数字：[0-9] \\D 非数字:[^\\d]/[^0-9] \\w 单词字符：[a-zA-Z_0-9] \\W 非字符[^\\w]边界匹配器^ 行的开头 $ 行的结尾 \\b 单词边界， 就是不是单词字符的地方。 Greedy 数量词X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 运算符XY X后跟 YX|Y X 或 Y(X) X，作为捕获组补充：123456789 //1.split 方法： String str1 = &quot;1 2 3 4 54 5 6&quot;; String[] numbers = str1.split(&quot; +&quot;); //+号表示一个或者多个空格 for (String temp : numbers) &#123; System.out.println(temp); &#125;//2. replaceFirst(String s);// replaceAll(String s);39. RTTI（Runtime Type Information）和反射机制反射是动态语言的关键，在运行的时候才去确定执行具体方法的具体的类，让灵活度更高，代码更高效。40.JRE和JDK的区别：&nbsp;&nbsp;&nbsp;&nbsp; JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核\\心，包括了Java运行环境JRE、Java工具和Java基础类库。Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。41. 泛型类，泛型接口，泛型方法泛型的使用使我们的代码更加具有通用性，不会导致定义了一种类型之后其他的类型都无法使用该代码42.1234Class C1 = new ArrayList&lt;Integer&gt;().getClass();Class C2 = new ArrayList&lt;String&gt;().getClass)();//在这里 C1==C2， 因为在泛型应用的内部，或者说容器中，默认都是储存的Object,只不过在取出元素时又会自动为你向下转型为对应的类型。 另外，对于基本类型，容器中其实默认存入存出的是他们的包装类，只是也为你自动打包和拆包了。43. 数组： 是Java中效率最高的粗讯和随机访问对象引用序列的方式。（代价是大小固定，不能自由扩展。） 数组可以储存基本数据类型。“创建的三种方式：123456789101112131415161718192021222324252627//1. String[] array1 = new String[3]; array1[0] = &quot;ni&quot;; array1[1] = &quot;hao&quot;; array1[2] = &quot;ma&quot;;//2. String[] array2 = new String[]&#123;&quot;ni&quot;,&quot;hao&quot;,&quot;ma&quot;&#125;;//3. String[] array3 = &#123;&quot;ni&quot;, &quot;hao&quot;, &quot;ma&quot;&#125;; System.out.println(Arrays.toString(array1)+&quot;\\n&quot; +Arrays.toString(array2)+&quot;\\n&quot; +Arrays.toString(array3)); //4. 多维数组 int[][] a = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8&#125;, &#125;; System.out.println(Arrays.deepToString(a)); //多维数组用deepToString打印补充：数组本身是一个对象，在保存基本类型时时直接存入的值，在保存对象时，时保存的引用地址。实用方法：Arrays.equal();//判断两个数组的内容是否相同，Arrays.deepEquals();//多维数组Arrays.sort(array); //排序,是根据元素类型的 comparaTo();方法决定的大小。Arrays.sort(arrays,Comparator); //根据自己定义的Comparator类比较排序，自带一个Collections.reverseOrder();会返回整个序列的倒序。Arrays.asList();Arrays.toString(array);System.arrayCopy(); //数组的赋值，比循环快多了Arrays.binarySearch(arrays,element （，Comparator）);//只能用于已经排序好的数组,返回位置，如果没找到，返回 -插入点（第一个比查找的元素大的位置）-1。比较数组元素： 1. implements Comparable重写 compareTo()方法 2. implements Comparator，重写compare（Obj o1, Obj o2） 在Arrays.sort（array，Comparator）里使用。 Comaparator和Comparable都是接口，需要声明类型还有一个Static方法：12345678910111213141516 Comparator&lt;Student&gt; com = Comparator.Comapring(Student::getID).thenComparing(Studeng::getName).reverse(); ``` &lt;br&gt; 44.三个 转义符,(当做字符串插入进去就生效了)： \\n,\\t,\\r &apos;\\t&apos; 空格 &apos;\\r&apos; 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； &apos;\\n&apos; 换行，换到当前位置的下一行，而不会回到行首； &lt;br&gt; 45. 网络: 不过多阐述，github有几个简单的小项目可以去看 [Java,Tcp小练习](https://github.com/ShengdongYan/JavaNetPractice)，简单总结一下各个常用类： &lt;br&gt;InetAddress ; InetSocketAddressURLTCP: ServerSocket, SocketUDP: DatagramSocket DatagramPackeßt12345&lt;br&gt; 46. IO：&lt;br&gt; - File: 路径的推荐填写方式： String path = &quot;E:/demo/test/2.txt&quot;; // 如果用编译器，应该写成相对路径，&quot;src/demo1/2.txt&quot; 也就是从src开始写&lt;br&gt;String path = &quot;E:\\\\demo\\\\test\\\\2.txt&quot;; //Win下的，不能跨平台，写双\\\\是因为，单\\会转义 // 在其他平台没有盘符， 直接/demo/test/2.txt 代表了绝对路径 String path = String.format(&quot;E:%sdemo%stest%sni.txt&quot;, File.separator, File.separator,File.separator); //用File类自带的分隔符 String path = &quot;E:/demo/test/2.txt&quot;; //最推荐，可以跨平台 File src = new File(&quot;test.txt&quot;); //在当前工作目录下的文件（可以填写还不存在的，不会自动新建） //一下全都返回的String,或者boolean src.getPath();//只能得到相对路径， 如果上边写了盘符，就可以得到绝对路径 src.getAbsolutePath();//得到绝对路径 src.getParent();//如果填写的相对路径，只会返回空 src.exists(); // false src.canWrite();// false src.isFile();//判断是文件还是文件夹，但是如果文件不存在，会默认判断成文件夹。 src.isDictionary();// src.length();//返回大小，以字节数为单位B，只有文件才能这样读取！ //通常写法: String path = &quot;E:/demo/test/2.txt&quot;; File src = new File(src); if(!src.exist()){ boolean flag = src.createNewFile(); sout(flag? &quot;成功&quot;：&quot;失败&quot;); } src.delete（）; //创建目录： 必须保证父目录正确,或者直接连通父目录一起创建 String path = &quot;E:/demo/test/demo2&quot;; File src = new File(src); src.mkdir(); src.mkdirs(); //同父目一起创建 String[] fileNames = src.list();//返回子目录中的文件名称们 File[] files = src.listFile(); //返回子目录中的File 以对象形式，可以加filefilter来过滤文件或者文件夹 //想读取文件夹中的所有子文件，应该自己手写一个递归方法。 123456789101112131415161718192021222324252627282930313233343536- IO流: 以程序为中心，面向文件，数组，网络连接，数据库。 &lt;font color = green&gt; 出现读写乱码是因为编码集（字符跟字节的对应集合）不同，比如Eclipse是自动写出的JDK编码模式，但是计算机本身是以UTF-8模式,也有小部分原因可能是因为字符长度缺失&lt;/font&gt; 设定字符集的两种方式： String st = new String (&quot;字符串&quot;，“utf-8”);&amp;emsp;&amp;emsp;&amp;emsp;或者 byte[] data = &quot;中国&quot;.getBytes(&quot;utf-8&quot;); - 按照数据分类 - 字节流： 二进制文件，可以包括一切文件 - InputStream类： read(byte[] b) ; read(byte[] b, int offset, int len); +close; - OutputStream类： write(byte[] b) ; write(byte[] b, int offset, int len); +flush+ close(); //每次写都要手动flush一次，不然他自己是等缓存区满了才会推出； - 字符流： 只能处理纯文本 txt. - Reader类： read(char[] c); read(char[] c, int off ,int len);+ close - Writer类： write(char[] c); write(char[] c, int off,int len); write(String str, int off, int len); +flush()+close(); - 按照功能分类 - 节点流： 包裹源头 InputStream OutputStream FileInputStream FileOutputStream Reader FileReader/Writer - 处理流，增强功能，提供性能 - 字节流具体的操作： 1. 读取文件： 选择文件 - 选择流 - 操作（read,write）- 释放资源。 ``` File src = new File（E:/demo/test/2.txt）； InputStream in = null; // 增加可用范围 try&#123; in = new FileInputStream(src); byte[] car = new byte[10]; //读取数据的缓存区； int len = 0； //一次真实的读几到了多少byte while(1!=(len=in.read(car)))&#123; //当返回的长度是-1，表示没有数据了。 String info = new String(car,0,len); sout(); &#125; &#125; catch(IoExeption e)&#123; //... &#125; finally&#123; in.close(); &#125; 2. 写文件同理，只是记得 在 建立连接时 OutputStream out =new FileOutputStream(src,false); //false表示不覆盖原文件内容 !!，每次写要 flush();一次. 3. 拷贝文件 12345678910111213File src = new File（E:/demo/test/2.txt）；File des = new File（E:/demo/test/2.txt）；InputStream in = new FileInputStream(src);OutputStream in = new FileOutputStream(des);byte[] car = new byte[];int len = 0; //最大读取1024个每次while(-1!=(len=in.read(car)))&#123; out.write(car,0,len); out.flush();&#125;out.flush();out.close(); //规则先打开的后关闭。in.close(); 4. 拷贝文件夹，用递归，这里不详述&lt;br&gt; - 字符流具体操作：(txt .java等等) 节点流用Reader Writer / FileReader, FileWriter 1. 文件读取 123456789101112131415161718192021 File src = new File（E:/demo/test/2.txt）； Reader in = null; // 增加可用范围 try&#123; in = new FileReader(src); char[] car = new char[10]; //读取数据的缓存区； int len = 0； //一次真实的读几到了多少byte while(1!=(len=reader.read(car)))&#123; //当返回的长度是-1，表示没有数据了。 String info = new String(car,0,len); sout(info); &#125;&#125; catch(IoExeption e)&#123; //...&#125;finally&#123; try&#123; in.close(); &#125; catch()&#123;&#125;&#125; 2. 文件写出，同上只是写出时 ，也分追加和覆盖 String msg = &quot;锄禾/r/n日当/r/n午\\r\\n&quot;; wr.write（msg）; wr.append(&quot;再多写点什么&quot;); wr.flush(); - 处理流的具体操作： 1. 针对字节流： 字节缓冲流 BufferedInputStream 直接在节点流外边包一层缓冲流即可： BufferedInputStream in = new BufferedInputStream(new FileInputStream(src)); //输出流一样，也没有新增方法 2. 针对字符流： 字符缓冲流 BufferedReader 新增方法 readLine(); write.newLine();//等于/r/n 新建声明的时候同上，只是新增了方法 BufferedReader reader = new BufferedReader(new FileReader(src)); String line = null; while(null!=(line=reader.readLine())){ //.... } 对于从console输入 一般如下： BufferedReader console = new BufferedReader(new InputStreamReader(System.in)); - 转换流： 字节流转换为字符流： OutputStreamWriter 编码， InputStreamReader 解码。 常用方式： BufferedReader reader = new BufferedReader(new InputStreamReader(new FileReader(new File(path))), &quot;utf-8&quot;); //读取文件的常用写法 - Scanner 和 io的区别： java.util.Scanner类是一个简单的文本扫描类，它可以解析基本数据类型和字符串。它本质上是使用正则表达式去读取不同的数据类型。 Java.io.BufferedReader类为了能够高效的读取字符序列，从字符输入流和字符缓冲区读取文本,一般用于处理硬件输入，如键盘。 Scanner in = new Scanner(System.in); String s = in.nextline(); //或者nextInt(),等基本类型和String. in = new Scanner(new File(path)); //读文件 47. 程序（application），线程（thread），进程（process），CPU的关系：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统资源分配的基本单元，在传统的操作系统中（单核），进程既是基本的分配单元，也是基本的执行单元。在计算机中，一个进程就代表着一个程序，一个进程至少有一个线程，CPU如果是多核处理器，可以同时处理多个线程，就像常说的四核八线程（如果是单核处理器，只能处理一个线程，但是可以来回切换线程来处理不同的程序）。48. Javadoc ,comment注释:Javadoc是Java自带的一种工具，其可以从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。Java中有三种注释方法：//被注释语句/被注释语句//*被注释语句/ß其中第三种专为JavaDoc设计，可以被JDK内置的Javadoc工具支持和处理。49.注解： Annotation， (不同于 Comment),作用是1.生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等；2.跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；3.在编译时进行格式检查。如@Override放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出；而Comment只有注释生成文档的作用。（简单来说，一种是给人看的，一种是给机器看的）50. 多线程： 三种创建线程的方法：extends Thread 重写run();方法，调用 .start();启动线程 注意不调用run方法，因为start方法内部为run()方法单独声明了一个线程出来，而run方法本身只是普通方法，不是线程， 比如在main里，多个线程同时调用run(),他们还是只能按照普通方法执行完一个再执行下一个，但是调用start他们就可以实现多线程，交替被调用。implements Runnable(); 重写.run(); new 一个Thread作为静态代理， start 这个Thread 代理即可。 好处是， 1. 解决了Java单继承问题，把继承位空出来了 2. 资源贡献更方便，可以new多个代理，去处理同一个资源implements Callable; 使用比较麻烦，但是可以有返回值和跑出异常外部干涉一个线程通常通过调用该线程的内部方法，而不是直接改变该线程的值 如下：线程中的静态方法包括： Thread.sleep(); Thread.yeild(); Thread.interrupted(); Thread.CurrentThread();1234567891011121314151617181920212223242526272829303132333435 /** * @Author: ShengdongYan * @Date: 2019-04-21 * @Version 1.0 */public class ThreadTest &#123; public static void main(String[] args) &#123; Counter t = new Counter(); new Thread(t).start(); for(int i= 0; i &lt; 600; i++)&#123; if(i == 400)&#123; t.stop(); // 手动直接 t.flag = false没用，不能及时生效，除非flag设置为 volatile（让一个变量对多个线程可见）. &#125; System.out.println(&quot;i in the outer class is &quot; + i); &#125; &#125;&#125;class Counter implements Runnable&#123; int i = 0; boolean flag = true; @Override public void run() &#123; while (flag)&#123; System.out.println(&quot;i in inner class is &quot; + i++); &#125; &#125; public void stop()&#123; flag = false; &#125;&#125;下面是 Join()方法（意思是另一个线程加入进来，当前线程等待加入的线程执行完毕再执行）：1234567891011121314 public static void main(String[] args) throws InterruptedException &#123; Counter t = new Counter(); Thread thr = new Thread(t); thr.start(); for(int i= 0; i &lt; 1000; i++)&#123; if(i == 20)&#123; thr.join(); //意思是另一个线程加入进来，当前main()线程等待加入的线程执行完毕再执行 &#125; System.out.println(&quot;i in the outer class is &quot; + i); &#125; &#125;&#125;&emsp;&emsp; Thread.sleep(); 静态方法: 让当前线程进阻塞状态（挂起），不释放锁，常用于1. 跟时间相关，比如倒计时。 2。 模拟网络延迟; 在哪个线程里调用那个线程就停止，不是根据 线程明+sleep; 所以想要让另一个线程sleep也只能另一个线程的自己内部封装好什么时候sleep，而不是其他的线程写 名字.sleep(); 如果非要主动让另一个线程sleep,最好也通过调用改变flag的方法，然后让该线程自己调用自己的sleep方法。123456789101112131415161718192021222324class Counter implements Runnable&#123; int i = 0; boolean flag = true; @Override public void run() &#123; while (i&lt;1000)&#123; sleeping(); System.out.println(&quot;i in inner class is &quot; + i++); &#125; &#125; public void stop()&#123; flag = false; &#125; public void sleeping() &#123; try&#123; Thread.sleep(1000);&#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;Thread.yeild（） 方法， 让当前线程释放CPU资源进入就绪状态，等待重新分配资源， sleep()，是进阻塞状态，不释放锁，必须等待睡完，才能重新就绪； 而wait（）；是释放锁，也是进入等待状态，可以用notify()；或者notifyAll();唤醒线程优先级 最大值10 ，最小值1， 默认5， 有setPriority 和getPriotity方法）； 优先级不是绝对的先，是被调度的概率大51. 线程安全问题： synchronized修饰符：用来保证同一个资源被多个线程访问的安全问题，比如多个不同的Thread代理去代理同一个东西（携程，途牛，飞猪票），执行该方法或者代码块，必须先获得锁可以修饰，方法，可以修饰代码块。 修饰代码块必须加上对应的类锁。 （一般保证了线程的安全，代码运行速度会变低，所以修饰方位不能过大）， 修饰方法相当于用this当锁，推用this当锁，修饰static 方法时相当于用当前的 class对象当锁。死锁： 多个线程互相等待资源的释放。（就像是： A线程想要一手交钱一手交货，B线程想要一手交货一手交钱，两个人都在等待对方先释放自己所需要的锁，这样就进入了死锁）,所以要尽量避免在同步方法中调用其他对象的同步方法，经典解决办法：生产者消费者模式。（wait(),notify()+flag实现）；52. Stack和heap的区别总而言之： 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小（new了对象就分配），生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。JVM的内存结构栈中放： (局部的)八大基本数据类型的数据，方法参数和局部变量，对象的引用比如int a=3; int b =3;此时系统会先在stack创立reference (参照类型) a然后找有没有字面值为3的地址没有的话会自己创一个再将a指向它接着创造reference b ,看到有字面值3的地址就指向它改b = 4也不会删掉3这个字面值,系统会新增一个4的字面值在stack然后再让b指向它堆中放： 基本数据类型的包装类， new 的对象和其全局变量， final的局部变量关于String补充，code区放方法代码， data区放static变量常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。53. JUnit1.@Test: 测试方法a)(expected=XXException.class)如果程序的异常和XXException.class一样，则测试通过b)(timeout=100)如果程序的执行能在100毫秒之内完成，则测试通过2.@Ignore: 被忽略的测试方法：加上之后，暂时不运行此段代码3.@Before: 每一个测试方法之前运行4.@After: 每一个测试方法之后运行5.@BeforeClass: 方法必须必须要是静态方法（static 声明），所有测试开始之前运行，注意区分before，是所有测试方法6.@AfterClass: 方法必须要是静态方法（static 声明），所有测试结束之后运行，注意区分 @AfterassertEquals((message)，expected ,actual); 和 assertEquals(expected.equals(actual)); 都是判断两个值是否相等，但是第一种方法错误提示更全面，所以更常用54. 空间复杂度一般只看额外占用了多少辅助空间，（简单技巧就是看一共new了多少东西），循环中的 i虽然在变，但是默认只占用了一个辅助单元123456int a = 9;int b = 10;int c = 11; // O(1); //常数阶---------int[] i = new int[n]; // 空间复杂度为O（n）;","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://dongdongyan.com/tags/Java基础/"}]},{"title":"Java容器基础知识总结（Collection框架)","slug":"Java容器基础知识总结（Collection框架","date":"2019-04-14T20:07:48.000Z","updated":"2019-05-05T21:45:41.538Z","comments":true,"path":"2019/04/14/Java容器基础知识总结（Collection框架/","link":"","permalink":"http://dongdongyan.com/2019/04/14/Java容器基础知识总结（Collection框架/","excerpt":"","text":"这里目前主要先用来总结一下Collection框架的基础知识，包括各个容器的优劣，使用场景等等. 这篇博客里有很多地方我自己比较清楚的，就没有详细写注释，如果不清楚哪个地方可以自己查看下面的官方文档JDK1.8中文官方文档Collection框架接口：注意： Array不属于这个框架里的类，应该用 Arrays.asList方法转化成list类型：12String[] strings = new String[]&#123;&quot;ni&quot;,&quot;hao&quot;&#125;;List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(strings));一些概述：在java.util.包中容器的打印无需任何帮助，其中的类都可以直接打印，Array想要打印就得先转换成List或者用 toString（）产生可打印表示。四大接口： Collection,Set,List,mapCollection接口的通用方法(衍生的类都自动有)：addAll(Collection c1, Collection c2); //把另一个collection子类的的元素并入第一里。Listlist = new ArrayList(Collections.nCopies(4,new Address()); // 用四个相同的address填充进去.add();.addAll()..remove();.size();.isEmpty();.clear();.toArray();.containsAll(Collection&lt;?&gt; c );.contains();.iterator();工具类 Collections（这是一个类，不要与Collection接口搞混）,方法介绍。Collections.fill(list, address1); //用指定的元素代替指定列表的所有元素。 Collections.copy(list,list2); //用两个参数，一个目标 List 和一个源 List, 将源的元素拷贝到目标，并覆盖它的内容。目标 List至少与源一样长。如果它更长，则在目标 List 中的剩余元素不受影响。 Collections.nCopies(4,new Address()); Collections.reverse(Collection c);//逆序一个容器的内容，可加 ,Comparator或者在自定义类实现Comparable接口； Collections.shuffle(Collection c);//乱序 Collections.sort(Collection c); //可加 ,Comparator或者在自定义类 实 现Comparable接口； Collections.binarySearch(Collection c, E element);//可加 , Comparator或者在自定义类实现Comparable接口； TreeSet&lt;Student&gt; students = new TreeSet&lt;Student&gt;( new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return o1.getName().compareTo(o2.getName()); } }); 1. List 有序可重复, 实现类：ArrayList: 擅长随机访问元素（ get(i)），但在List中间插入和移动元素很慢,线程不安全，一般使用； 源码，底层是数组，每次扩展变成1.5倍容量，默认长度是10。List&lt;String&gt; slist = new ArrayList&lt;&gt;(Arrays.asList(&quot;wo&quot;,&quot;hao&quot;,&quot;ma&quot;)); slist.add(element); slist.add(index, element); //也可以加位置，来插人固定位置。 slist.get(0); slist.remove(); slist.clear()//清空； slist.size(); slist.contans(&quot;ni&quot;);//返回boolean，判断是否存在，会根据元素类 .equals（）方法判断，基础知识篇已经讲过。 slist.indexOf(“h”); //根据equals()方法先判断存在，再返回位置，如果没有返回-1； .containsAll(); //判断是否包含了另一个ArrayList的所有元素，顺序不重要。 .subList(1,2); //截取一个新的，老的不影响。 .removeAll(); // 也是根据equals()方法。 .retainAll(list1,list2); //交集 .toArray(); .set(位置,元素 )； //替换 LinkedList: 在List中插入和删除很快，优化了顺序的访问，但是在随机访问方面很慢,线程不安全。（Java 中是双向的，doublelinkedlist）getFirst(); //= element(); 返回第一个元素，如果为空会报错，但是 peek（）；在为空会返回null; removeFirst(); // = remove(); poll(); addFirst();// =add(); 在最后 addLast(); removeLast();// 返回并移除； Vector: 底层，array， 线程安全，效率低，相当于ArrayList中的方法都加了Synchronized。2. Stack(栈)：底层是数组 ,继承自Vector类，Vector继承自AbstractList。 但是一般我们利用ArrayList或者LinkedList自己重写实现一个属于自己的Stack类Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(9); LIFO，peek（）；// 得到最上边的元素却不推出pop();//返回并推出3. Set不保存重复的元素（add新元素不会报错，还是只剩一个），无序，可以有一个为空的元素，最常用到的地方是测试归属性，可以很容易的查到某个对象是否在set中，长处就是快速查找。 contans(); 没有新增方法，方法同Collection1234567//读取一个文件中的单词： Set&lt;String&gt; words = new TreeSet&lt;String&gt;( new TextFile(&quot;SetText.txt&quot;, &quot;\\\\W+&quot;)); //意思是把 .txt文件里的内容按照 正则表达式断开为单词元素，并传入 一个set. //或者直接传入一个其他的collection，自动去去除其中的重复项。Set&lt;String&gt; set = new HashSet&lt;&gt;(Collectiion&lt;String&gt; C);HashSet: 底层是用的HashMap实现的，只是把Value都设成了同样的固定值(一个空的Object)。TreeSet: 简化版的TreeMap, 底层是TreeMap.4. Map专用于解决储存映射关系，或者对应关系的问题。 HashMap擅长快速查询和访问，TreeMap会自动排序keys,LinkedHashMap保证了插入的顺序。（同对应的set.） 键不能重复，value可以重复。123456Map&lt;String, String&gt; = new HashMap&lt;String,String&gt;();get(key);// 返回对应的value,put(key,value);//putAll(map);containsKey(key);containsValue(value); HashMap: 底层是数组加（单向）链表，当链表长度大于8，自动变成红黑树，这样查询的速率又提高了。 （允许存入空的 key和value）如果要加入同key的，会更新value。通过key,读取value的过程：先通过key的hashcode取得key的hash()返回值，然后找到对应的链表，一个个开始对比key的eual方法。 （有时候hashcode可能会相同，但是不 ==。但是如果 equal，哈希值就相同，就是相同）扩容，当数组内容超过 0.75，自动 System.arrayCopy（）到容量2倍的新数组。TreeMap: 需要在MAP里排序的时候用，底层是用红黑二叉树，存入后自动排序。基本类型自带了Comparable，不是基本类型的话需要自己重写compareTo();HashTable: 底层与hashmap几乎一样，只是加了很多synchronized,保证了线程安全，效率相对低。不允许key 和value为空。5. Queue (是个接口) 双端队列Deque是其子接口（可以从双端插入可取出）。FIFO: 常用语将对象从程序的某个区域传到领一个区域的途径。1. Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); offer(); //插入队尾，或者返回false； peek（）；// = element（）；在不删除的情况下返回队首 poll(); // remove(); 在移除的情况下返回队首； 他们的共同之处是建议实现类禁止添加 null 元素，否则会报空指针 NullPointerException； 不同之处在于 add() 方法在添加失败（比如队列已满）时会报 一些运行时错误 错；而 offer() 方法即使在添加失败时也不会奔溃，只会返回 false。 优先级队列： PriorityQueue&lt;Integer&gt; priorityqueue = new PriorityQueue&lt;Integer&gt;(); //自动排序， 你可以通过Comparator修改。 Dequeue:.addFirst();.addLast();.pollFirst();.pollLast();PriorityQueue:12345PriorityQueue&lt;String&gt; prique = new PriorityQueue&lt;String&gt;(10,new Comparator&lt;String&gt;&#123; public int compare(String s1,String s2)&#123; return s1.compareTo(s2); &#125;&#125;);6. Iterator(迭代器):Java中的迭代器只能单向移动，Collection接口已经implements Iterable接口了，所以只能：1234567891011121314151617181920212223241. .iterator()方法返回该容器的Iterator Iterator&lt;String&gt; it = slist.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;2. next();3. hasNext();4. remove(); //注意这里移除的是 next()返回的最新元素（或者说访问过的最后一个元素）， 不是调用next()后的下一个元素。 **如果只打算遍历，不打算修改，foreach是更好的选择**5. ListIterator 是专门为ArrayList设计的，功能更强，可以访问前一个元素的和后一个元素的索引，还有set方法。6. 对于Map,因为不属于Collection下面，所以有两种方式 1. Set&lt;Entry&lt;E key, E value &gt;&gt; = map.entrySet(); 在循环里再 Entry&lt;E key, E value &gt; = iterator.next();得到每一个元素。 2. 对于Map,可以keySet(), (valueSet());分别得到keyset,再进行遍历7. 容器中的泛型泛型的底层相关是擦除的知识，在存入时所有具体类型的信息都会被忘记12Class C1 = new ArrayList&lt;Integer&gt;().getClass();Class C2 = new ArrayList&lt;String&gt;().getClass)();//在这里 C1==C2， 因为在泛型应用的内部，或者说容器中，默认都是储存的Object,只不过在取出元素时又会自动为你向下转型为对应的类型。 另外， 对于基本类型，容器声明的时候的类型只能是其包装类，因为基本数据类型不是一种类。 但是.add(10); 可以写入int,会发生自动拆包和封箱（当int作为唯一参数传入一个要求是integer的方法时会发生，其实相当于 arrayList.add(Integer.valueOf(100));）。8. 应用场景经典应用，打印表格， 一般表格可以有两种存取方法：List+Map(表格的头当做不同的Key,对应的每个值当做value，然后Map存入ArrayList)List+自定义内部类","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Java基础， Collection框架，Java容器","slug":"Java基础，-Collection框架，Java容器","permalink":"http://dongdongyan.com/tags/Java基础，-Collection框架，Java容器/"}]},{"title":"SE-UML图类总结","slug":"SE-UML图类总结","date":"2019-04-13T21:41:02.000Z","updated":"2019-04-29T17:17:45.264Z","comments":true,"path":"2019/04/13/SE-UML图类总结/","link":"","permalink":"http://dongdongyan.com/2019/04/13/SE-UML图类总结/","excerpt":"","text":"最近有场Software Engineering考试，趁机总结一波各种UML图的画法，包括UserCase, State, Activity, Sequence, FirstCut Diagram 等等1. Usercase Diagram（用例图）基本元素：用例图中包含6个元素，分别是执行者（Actor），用例（Use Case），关联关系（Association），包含关系(Include)，扩展关系(Extend)以及泛化关系(Generalization)。如何选Actor:1234567891）有哪些直接使用系统的人2）涉及到哪些维护人员3）使用哪些外设4）相连的其他系统5）还有哪些人和事物对这个系统产生的结果感兴趣。《include》 关键字：主要有以下两种情况需要用到包含关系。多个用例用到同一段的行为，则可以把这段共同行为单独地抽象成一个用例，然后让其他用例来包含这一用例。当某一个用例功能过多，事件流过于复杂时，也可以把某一段事件流抽象成一个被包含的用例，以达到简化描述的目的。《extends》 关键字在一定条件下，把新的行为加入到已有的用例中，获得的新用例叫做扩展用例总结： Usercase Diagram 就是先找出几个可能的actor,然后先只画出主要的活动，在用 include 或者extends扩展活动。Activity diagram(活动图)if-else（或）表示：并发、并行表示：例子：This figure below describes the business process for meeting a new client using an activity Diagram with swinlane.总结： 主要是符号别用错，分好大的区间Partition，一个对象一个区间，每个区间里的行为都是由该对象作出的。Class Diagram关系; 关系的详解记住下面的图即可，一般只会用到关联，组合，聚合。数量关系：总结： 这次考试大概只需要写First cut，看看课件的例子比较好Sequence Diagram详细介绍：提示： 控制焦点两端要以消息元素封顶，控制焦点不要超过消息元素。State diagram课件很详细，这随便上个例题Component Diagram","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://dongdongyan.com/categories/计算机基础知识/"}],"tags":[{"name":"SE","slug":"SE","permalink":"http://dongdongyan.com/tags/SE/"},{"name":"UML","slug":"UML","permalink":"http://dongdongyan.com/tags/UML/"}]},{"title":"Java问题汇总","slug":"Java面试准备","date":"2019-04-12T21:41:02.000Z","updated":"2019-04-28T12:26:04.780Z","comments":true,"path":"2019/04/12/Java面试准备/","link":"","permalink":"http://dongdongyan.com/2019/04/12/Java面试准备/","excerpt":"","text":"这里记录一些常见的问题以及答案，主要是针对Java面试。一 多线程问题死锁的概念，以及会写死锁小程序。（多个线程互相锁也是死锁的一种）在A线程正在执行一个对象中的同步方法，B线程是否可以同时执行同一个对象的非同步方法可以，跟下边的题一样，只要不是非同步都随便走。在同一个类中，当其中的同步方法执行时，可以执行另一个非同步方法吗？可以，非同步的方法可以再该线程或者其他线程执行，没有影响在一个同步方法中可以调用同一个类中的另一个同步方法并顺利执行吗？可以 ，同一个线程，同一个锁，可以顺利执行程序执行过程中，如果同步问题出现异常，锁会被释放吗？会的，所以要多加小心，如果不想释放，加try catch做出处理volatile关键字和synchronized的区别。volatile比较快，轻量级。保证了线程间，内存的可见性，如果不用volatile，就得上sychronized,来保证资源的调度一致性。（但是volatile只保证了可见性，syhcronized既保证了可见性，又保证了原子性，不能用volatile代替syncronized,当我们只需要保证可见性时才用volatile）AtomXXX类跟sychronized比为什么更高效？更上边一样，为了提高效率。 保证了调用的方法原子性，做一些常见的加减很好用。但是，不能保证多个方法的连续调用还有原子性（其他线程可能会进来操作）。比如银行账户系统，只同步set(); 不同步get行不行（）； 不行，因为就算set（）；每次只能被一个线程用，其他线程很有可能在set执行的过程中，不断的读取，还是会出错。","categories":[{"name":"Java","slug":"Java","permalink":"http://dongdongyan.com/categories/Java/"}],"tags":[{"name":"Java问题","slug":"Java问题","permalink":"http://dongdongyan.com/tags/Java问题/"}]},{"title":"机器语言的分类（高级，低级，动态，强类型，面向对象等等）","slug":"机器语言的分类","date":"2019-04-08T14:13:13.000Z","updated":"2019-04-28T11:26:21.697Z","comments":true,"path":"2019/04/08/机器语言的分类/","link":"","permalink":"http://dongdongyan.com/2019/04/08/机器语言的分类/","excerpt":"","text":"计算机语言的几种分类常见的几种分类高级语言和低级语言动态类型和静态类型强制类型和弱类型编译型，解释型，半编译半解释面向对象型和面向过程型1. 高级语言和低级语言常见的低级语言有：机器码、汇编语言(assembly language)高级语言常见如：c，c++，java，python，PHP，c#，Ruby，go，kotlin，swift。机器码：计算机能够直接识别的二级制编码，无论语言多高级都要转成二级制文件来让计算机识别运行。汇编：用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，在不同的设备中有着不同的指令集下面是一个LMC的例子：(little man language)12345678910111213INPSTA AL OUTADD ASTA BSUB CBRP ELDA BBRA LE HLTA DATB DATC DAT 100高级语言：为省去编程时候的不必要的操作细节，节省代码量，可读性强，维护性强，更贴近人性化高级语言与低级语言的区别：高级语言大部分不能直接更硬件打交道，这使得相对来的程序运行速度降低，总之一句话来说那种语言更接近人性化的语言就更高级。2. 动态类型和静态类型动态性语言是指在程序运行期间才给变量指定数据的类型，（数据类型可以根据环境改变） 常见于Object-C、C#、JavaScript、PHP、Python、Erlang等，而静态类型语言则恰好相反，在写程序代码的时候就要指定变量的类型，这种语言有：c，c++，java3. 强制类型与弱类型我们可知C语言中，一个变量只能定义为一种类型，如float类型，那么它就只能是float类型而不能在不发生转化的情况下赋予int类型，这就是 强制类型 的具体体现。而python和js不是，python中的变量可以任意的复制，而没有类型的界限。这就是弱类型强制类型更严谨，更不容易出现错误，但弱类型的语言写起来更优雅，更舒畅4. 编译型，解释型，半编译半解释对于源程序，编译型语言在执行程序中会将源文件一次性的转化为机器码，而解释型语言是边编译边解释；解释型语言是离不开解释程序的，这也导致了解释性语言对于运行时候的速度比价慢，解释型语言只要有解释器，移植起来比较方便，而编译型语言则要对于不同的系统进行编译，是的工作繁琐，且在调试程序的时候比较慢编译型语言可见于c，c++等解释型语言可见于python，JavaScript，Perl，shell等而java和c#是半编译半解释型的语言，java会将源文件在jVM中转化为字节码，即.class文件，在程序运行的时候转化为二进制文件。和C#中的.net有点区别，C#编译的成的.net目标代码（中间码），接近与二进制文件，可移植性没有java好，java是“一次编译，到处执行”，c#是“一次编码，到处编译”。5. 面向对象型和面向过程型面向过程是决定该怎么铺成一条路到达终点，而面向对象是要用那些具有特定功能的像来做，两者是不同的思想。c++是部部分面对对象的，java具有封装性是完全面对对象的，c语言是面对过程的语言","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://dongdongyan.com/categories/计算机基础知识/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://dongdongyan.com/tags/计算机基础/"},{"name":"编程语言","slug":"编程语言","permalink":"http://dongdongyan.com/tags/编程语言/"}]},{"title":"写博客的Markdown语法介绍","slug":"写博客的Markdown语法介绍","date":"2019-04-07T20:19:15.000Z","updated":"2019-04-08T22:51:59.663Z","comments":true,"path":"2019/04/07/写博客的Markdown语法介绍/","link":"","permalink":"http://dongdongyan.com/2019/04/07/写博客的Markdown语法介绍/","excerpt":"","text":"md语法已经成了程序员的一项必备技能作为程序员，学会用markdown文本编辑代替传统的Office全家桶才够酷。重要的是，写一些博文，甚至在网上发表评论的时候，md语法几乎是必备的。现在大部分的论坛和网站都已经默认支持了md语法，包括github，简书,csdn,博客园等等。以.md结尾的文件就是用markdown语法的地方了，推荐用VScode进行编辑，可以在编辑的同时直接在右侧预览效果。如下：所以，总之作为程序员，如果不会基本的md语法那你就out啦！md语法已经有很多成熟的介绍文章了，所以我直接引用了一篇比较基础的，也方便以后我自己复习下面是引用内容：一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。示例：123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题效果：这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体加粗要加粗的文字左右分别用两个*号包起来斜体要倾斜的文字左右分别用一个*号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来示例：1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容效果如下：这是引用的内容这是引用的内容这是引用的内容四、分割线三个或者三个以上的 - 或者 * 都可以。示例：1234-------********效果如下：五、图片语法：1![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加示例：12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)效果如下：上传本地图片直接点击导航栏的图片标志，选择图片即可六、超链接语法：1[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加示例：12[简书](http://jianshu.com)[百度](http://baidu.com)效果如下：简书百度注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例简书七、列表无序列表语法：1234无序列表用 - + * 任何一种都可以- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格效果如下：列表内容列表内容列表内容有序列表语法：数字加点123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格效果如下：列表内容列表内容列表内容列表嵌套上一级和下一级之间敲三个空格即可1234- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容效果一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容1234- 一级无序列表内容 1. 二级无序列表内容 2. 二级无序列表内容 3. 二级无序列表内容效果一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容123456781. 一级无序列表内容 1. 二级无序列表内容 2. 二级无序列表内容 3. 二级无序列表内容2. 一级无序列表内容 1. 二级无序列表内容 2. 二级无序列表内容 3. 二级无序列表内容效果一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容一级无序列表内容二级无序列表内容二级无序列表内容二级无序列表内容八、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略示例：12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟效果如下：姓名技能排行刘备哭大哥关羽打二哥张飞骂三弟九、代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容`代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行1234567(```) 代码... 代码... 代码...(```)注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。效果如下：create database hero;代码块1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();十、流程图123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;`效果如下：有些地方可能不支持流程图，所以截了个图：十一、补充实现缩进两种方案手动输入空格 （&amp;nbsp；）。注意！此时的分号为英文分号，但是不推荐使用此方法，太麻烦！使用全角空格(切换快捷键shift+空格)。即：在全角输入状态下直接使用空格键就ok了实现换行两种方案两个回车即可使用&lt; br &gt;字体大小、颜色、类型、加粗、倾斜&lt; font size=5&gt; Hello&lt; font color=red&gt;color&lt; font face=“微软雅黑”&gt;微软雅黑内容 (*与内容之间没有空格)内容 (*与内容之间没有空格)参考来源作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。再推荐一个比较全面的： markdown文档大全","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"},{"name":"markdown","slug":"markdown","permalink":"http://dongdongyan.com/tags/markdown/"}]},{"title":"分类和标签功能测试","slug":"标签和分类测试","date":"2019-04-03T00:38:16.000Z","updated":"2019-04-07T21:52:48.768Z","comments":true,"path":"2019/04/03/标签和分类测试/","link":"","permalink":"http://dongdongyan.com/2019/04/03/标签和分类测试/","excerpt":"","text":"只是用于测试分类和标签功能md文件各属性填写如下：12345title: 分类和标签功能测试date: 2019-04-03 01:38:16categories: 日常随笔tags: [Java,Hexo,git]toc: true # 是否启用内容索引由于本主题的左侧tags 和 categories页面不自动生成，我从主题作者github库中的issues得知两个方法:移动 themes/source/tags和categories文件夹 到根目录的soucre下即可 （但是我自己这边不太好用）12hexo new page “tags” hexo new page “categories”经过亲测， 先移动文件夹再new page一定可以凑效。 其实也可以直接new page 然后修改文件头如上示例。","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://dongdongyan.com/tags/Hexo主题/"}]},{"title":"Blog Theme English document","slug":"README","date":"2019-04-02T19:23:37.000Z","updated":"2019-04-07T21:31:49.213Z","comments":true,"path":"2019/04/02/README/","link":"","permalink":"http://dongdongyan.com/2019/04/02/README/","excerpt":"","text":"pureA brand new default theme for [Hexo]. Preview | 中文说明文档 | iconfontFeaturesMultiple languages supportComment supportTags pageCategories pageSocial MediaSkinsAppearanceHome | Archives | Categories | Tags | Repository | Books | Links | AboutInstall themeExecute the following command under your hexo folder.1git clone https://github.com/cofess/hexo-theme-pure.git themes/pureThen modify the property theme of the file hexo/_config.yml to theme: pureUpdate themeExecute the following command to update theme.12cd themes/puregit pullInstall pluginhexo-wordcount1npm install hexo-wordcount --savehexo-generator-json-content1npm install hexo-generator-json-content --savehexo-generator-feed1npm install hexo-generator-feed --savehexo-generator-sitemap1npm install hexo-generator-sitemap --savehexo-generator-baidu-sitemap1npm install hexo-generator-baidu-sitemap --saveData filesSometimes you may need to use some data in templates which is not directly available in your posts, or you want to reuse the data elsewhere. For such use cases, Hexo 3 introduced the new Data files. This feature loads YAML or JSON files in source/_data folder so you can use them in your site.For example, add links.yml in source/_data folder.links dataadd links.yml in source/_data folder.The format of the link :1234Name: link: http://example.com avatar: http://example.com/avatar.png desc: descriptionAdd a number of links, we just need to repeat the format according to the above.Blog optimizationhexo-neatauto Minify html、js、css and make it neat1npm install hexo-neat --saveYou can configure this plugin in _config.yml.12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &apos;*.min.css&apos;neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos;hexo-baidu-url-submit1npm install hexo-baidu-url-submit --savehexo-translate-titletranslate the chinese title of Hexo blog to english words automatially1npm install hexo-translate-title --saveYou can configure this plugin in _config.yml.123456translate_title: translate_way: google #google | baidu | youdao youdao_api_key: XXX youdao_keyfrom: XXX is_need_proxy: true #true | false proxy_url: http://localhost:8123Mathjax Supporthexo-renderer-markdown-it-plusinstall12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --saveYou can configure this plugin in _config.yml.12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: falseArticle enable mathjax12title: Hello Worldmathjax: true","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://dongdongyan.com/tags/随笔/"},{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"}]},{"title":"博客主题中文文档","slug":"README.cn","date":"2019-04-02T19:23:37.000Z","updated":"2019-04-07T21:31:51.491Z","comments":true,"path":"2019/04/02/README.cn/","link":"","permalink":"http://dongdongyan.com/2019/04/02/README.cn/","excerpt":"","text":"pureA brand new default theme for [Hexo]. Preview | English documentation | iconfont特色多语言第三方评论框（友言、来必力、gitment、gitalk）可展示个人豆瓣书单可展示个人github托管项目可设置支付宝、微信打赏主题颜色页面展示首页 | 归档 | 分类 | 标签 | 项目 | 书单 | 友链 | 关于配置说明在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件安装主题1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure更新主题12cd themes/puregit pull启用pure主题打开站点配置文件，找到theme字段，将其值更改为 pure1theme: pure到此，主题安装完成。然后启动Hexo服务验证主题是否正确启用。1hexo s安装插件hexo-wordcount1npm install hexo-wordcount --savehexo-generator-json-content1npm install hexo-generator-json-content --savehexo-generator-feed1npm install hexo-generator-feed --savehexo-generator-sitemap1npm install hexo-generator-sitemap --savehexo-generator-baidu-sitemap1npm install hexo-generator-baidu-sitemap --save主题配置设置语言打开站点配置文件, 将 language 设置成你所需要的语言。建议明确设置你所需要的语言,可选值对应themes\\pure\\languages目录下语言文件，简体中文配置如下：1language: zh-CN主题颜色定制了五套颜色，默认白，黑:theme-black，蓝:theme-blue，绿:theme-green，紫:theme-purple123# configconfig: skin: # 主题颜色 theme-black theme-blue theme-green theme-purple导航菜单12345678910111213141516171819202122# 导航菜单menu: Home: . Archives: archives # 归档 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories Books: books # 书单 Links: links # 友链 About: about # 关于# 导航菜单图标（font awesome）menu_icons: enable: true # 是否启用菜单图标 home: icon-home-fill archives: icon-archives-fill categories: icon-folder tags: icon-tags repository: icon-project books: icon-book-fill links: icon-friendship about: icon-cup-fill设置个人信息123头像在themes\\pure\\source\\images 目录下替换图片即可，捐献的二维码同理。个人信息大部分都在 主题配置文件 中设置搜索主题内置三种站内搜索方式：insight、swiftype、baidu12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search分享支持weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedin123456# Share# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: true # 是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,qq,qzone # 移动端显示的分享图标评论主题集成了disqus、友言、来必力、gitment、gitalk评论系统，选择其中一种即可12345678910111213141516# Comment# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/comment: type: livere # 启用哪种评论系统 disqus: # enter disqus shortname here youyan: uid: *** # enter youyan uid livere: uid: *** # enter livere uid gitment: githubID: username repo: username.github.io ClientID: *** ClientSecret: *** lazy: false文章浏览量统计主题内置了不蒜子和leancloud来统计文章浏览量，启用其中之一即可，注意leancloud需要到其官网申请APP ID 和APP Key。比如，启用不蒜子来统计文章浏览量，在主题配置文件中把busuanzi设置为true即可：123pv: busuanzi: enable: true # 不蒜子统计如果不需要第三方来统计浏览量，只需将相应设置改为false即可（设置为false后不会加载第三方JS脚本）Github respostory复制theme/pure/_source/ 目录下repository文件夹到blog path/source/ 目录下123# Githubgithub: username: *** # github username豆瓣书单复制theme/pure/_source/ 目录下books文件夹到blog path/source/ 目录下12345# douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数友情链接复制theme/pure/_source/ 目录下links文件夹到blog path/source/ 目录下在 hexo 目录下的 source 文件夹内创建一个名为 _data（禁止改名）的文件夹。然后在文件内创建一个名为 links.yml 的文件,在其中添加相关数据即可。单个友情链接的格式为：1234Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot;添加多个友情链接，我们只需要根据上面的格式重复填写即可。. 将 Name 改为友情链接的名字，例如 Cofess。. http://example.com 为友情链接的地址。. http://example.com/avatar.png 为友情链接的头像。. 这是一个描述 为友情链接描述。文章索引目录123456title: 文章标题categories: - 文章分类tags: - 文章标签toc: true # 是否启用内容索引sidebar侧边栏文章侧边栏默认为开启状态，如果某篇文章不想开启侧边栏，在文章开头配置加入“sidebar: none”即可：123456title: 文章标题categories: - 文章分类tags: - 文章标签sidebar: none # 是否启用sidebar侧边栏，none：不启用博客优化hexo-neatauto Minify html、js、css and make it neat1npm install hexo-neat --save在博客配置文件_config.yml中添加12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &apos;*.min.css&apos;neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos;hexo-baidu-url-submit1npm install hexo-baidu-url-submit --savehexo-translate-title使用Google翻译，百度翻译和有道翻译将Hexo中的汉字标题转成英文标题安装1npm install hexo-translate-title --save在博客配置文件_config.yml中添加123456translate_title: translate_way: google #google | baidu | youdao youdao_api_key: XXX youdao_keyfrom: XXX is_need_proxy: true #true | false proxy_url: http://localhost:8123注意：判断是否需要配置google本地代理，因为我在本地是开启时才能访问google翻译的，如果没有被墙，请将_config.yml 下的is_need_proxy: true改为false。如果设置为true,请设置本地代理地址数学公式Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签解决方案解决方案有很多，可以网上搜下，为了节省大家的时间，这里只提供亲身测试过的方法。更换Hexo的markdown渲染引擎，hexo-renderer-markdown-it-plus引擎替换默认的渲染引擎hexo-renderer-marked即可。安装hexo-renderer-markdown-it-plus插件12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save配置安装插件后，如果未正常渲染LaTeX数学公式，在博客配置文件_config.yml中添加12345678910111213141516markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: false文章启用mathjax12title: Hello Worldmathjax: true","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://dongdongyan.com/tags/随笔/"},{"name":"Hexo","slug":"Hexo","permalink":"http://dongdongyan.com/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"http://dongdongyan.com/tags/建站/"}]},{"title":"Speed Test(书写格式模板)","slug":"Test","date":"2019-03-26T20:23:37.000Z","updated":"2019-04-20T14:31:48.245Z","comments":true,"path":"2019/03/26/Test/","link":"","permalink":"http://dongdongyan.com/2019/03/26/Test/","excerpt":"","text":"第一章 上二级标题测试再来一个二级标题第二章 中第三章 下- 第一章 上只是测试一下如果用Github托管，在国内浏览此博客的速度你说呢br要加在上一行的后边我也不知道啊你呢我不知道1一个代码看看行不我觉得你这个代码不是很好1你再看看这个代码怎么样！到底知道不知道1试试就知道那你知道吗？- 再来一个二级标题第二章 中第三章 下","categories":[{"name":"日常随笔","slug":"日常随笔","permalink":"http://dongdongyan.com/categories/日常随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://dongdongyan.com/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-26T20:20:00.404Z","updated":"2019-04-19T20:38:47.168Z","comments":true,"path":"2019/03/26/hello-world/","link":"","permalink":"http://dongdongyan.com/2019/03/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}